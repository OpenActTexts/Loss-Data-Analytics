
```{r include = FALSE}
chapnum = 6

```


# Simulation and Resampling {#ChapSimulation}

*Chapter Preview.* Simulation is a computationally intensive method used to solve difficult problems. Instead of creating physical processes and experimenting with them in order to understand their operational characteristics, a simulation study is based on a computer representation - it considers various hypothetical conditions as inputs and summarizes the results. Through simulation, a vast number of hypothetical conditions can be quickly and inexpensively examined. Section \@ref(S:SimulationFundamentals) introduces simulation, a wonderful computational tool that is especially useful in complex, multivariate settings.

We can also use simulation to draw from an empirical distribution - this process is known as resampling. Resampling allows us to assess the uncertainty of estimates in complex models. Section \@ref(S:Bootstrap) introduces resampling in the context of bootstrapping to determine the precision of estimators.

Subsequent sections introduce other topics in resampling. Section \@ref(S:CrossValidation) on cross-validation shows how to use it for model selection and validation. Section \@ref(S:ImportanceSampling) on importance sampling describes resampling in specific regions of interest, such as long-tailed actuarial applications. Section \@ref(S:MCMC) on Monte Carlo Markov Chain (MCMC) introduces the simulation and resampling engine underpinning much of modern Bayesian analysis.


## Simulation Fundamentals {#S:SimulationFundamentals}

***
In this section, you learn how to:

-   Generate approximately independent realizations that are uniformly distributed
-   Transform the uniformly distributed realizations to observations
    from a probability distribution of interest
-   Calculate quantities of interest and determine the precision of the calculated quantities

***

<!-- ## Simulation Fundamentals -->


### Generating Independent Uniform Observations

The `r Gloss('simulations')` that we consider are generated by computers. A major strength of this approach is that they can be replicated, allowing us to check and improve our work. Naturally, this also means that they are not really random. Nonetheless, algorithms have been produced so that results appear to be random for all practical purposes. Specifically, they pass sophisticated tests of independence and can be designed so that they come from a single distribution - our `r Gloss('iid')` assumption, identically and independently distributed. 

To get a sense as to what these algorithms do, we consider a historically prominent method.

**Linear Congruential Generator.** To generate a sequence of random numbers, start with $B_0$, a starting value that is known as a *seed*. This value is updated using the recursive relationship
$$B_{n+1} = (a B_n + c)  \text{ modulo }m, ~~ n=0, 1, 2, \ldots .$$
This algorithm is called a `r Gloss('linear congruential generator')`. The case of
$c=0$ is called a *multiplicative* congruential generator; it is
particularly useful for really fast computations.

For illustrative values of $a$ and $m$, Microsoft's Visual Basic uses
$m=2^{24}$, $a=1,140,671,485$, and $c = 12,820,163$ (see
<https://en.wikipedia.org/wiki/Linear_congruential_generator>). This is the engine underlying
the random number generation in Microsoft's Excel program.

The sequence used by the analyst is defined as $U_n=B_n/m.$ The analyst
may interpret the sequence {$U_{i}$} to be (approximately) identically
and independently uniformly distributed on the interval (0,1). To
illustrate the algorithm, consider the following.

**Example `r chapnum`.1.1. Illustrative Sequence.**
Take $m=15$, $a=3$, $c=2$ and $B_0=1$. Then we have:

   step $n$  $B_n$                                      $U_n$
  ---------- --------------------------------- ------------------------
      0      $B_0=1$                           
      1      $B_1 =\mod(3 \times 1 +2) = 5$      $U_1 = \frac{5}{15}$
      2      $B_2 =\mod(3 \times 5 +2) = 2$      $U_2 = \frac{2}{15}$
      3      $B_3 =\mod(3 \times 2 +2) = 8$     $U_3 = \frac{8}{15}$
      4      $B_4 =\mod(3 \times 8 +2) = 11$    $U_4 = \frac{11}{15}$
  ---------- --------------------------------- ------------------------

Sometimes computer generated random results are known as `r Gloss("pseudo-random numbers")` to reflect the fact that they are machine generated and can be
replicated. That is, despite the fact that {$U_{i}$} appears to be
i.i.d, it can be reproduced by using the same seed number (and the same
algorithm). 


**Example `r chapnum`.1.2. Generating Uniform Random Numbers in `R`.**
The following code shows how to generate three uniform (0,1) numbers in `R` using the `runif` command. The `set.seed()` function sets the initial seed. In many computer packages, the initial seed is set using the system clock unless specified otherwise.


##### Three Uniform Random Variates {-}

```{r myirischunk, results = 'asis', comment = "", echo=SHOW_PDF}
set.seed(2017)
U <- runif(3)
knitr::kable(U, digits=5, align = "c", col.names = "Uniform")
```

***

The linear congruential generator is just one method of producing
pseudo-random outcomes. It is easy to understand and is widely
used. The linear congruential generator does have limitations, including
the fact that it is possible to detect long-run patterns over time in
the sequences generated (recall that we can interpret *independence* to
mean a total lack of functional patterns). Not surprisingly, advanced
techniques have been developed that address some of this method's
drawbacks.

### Inverse Transform Method {#S:InverseTransform}

With the sequence of uniform random numbers, we next transform them to a distribution of interest, say $F$. A prominent technique is the `r Gloss('inverse transform method')`, defined as

$$
X_i=F^{-1}\left( U_i \right) .
$$

Here, recall from Section 4.1.1 that we introduced the inverse of the distribution function, $F^{-1}$, and referred to it also as the `r Gloss('quantile function')`. Specifically, it is defined to be 

$$
F^{-1}(y) = \inf_x ~ \{ F(x) \ge y \} .
$$

Recall that $\inf$ stands for *infimum* or the `r Gloss('greatest lower bound')`. It is essentially the smallest value of *x* that satisfies the inequality $\{F(x) \ge y\}$.
The result is that the sequence {$X_{i}$} is approximately *iid* with distribution function $F$ if the {$U_i$} are *iid* with uniform on $(0,1)$ distribution function.

The inverse transform result is available when the underlying random variable is continuous, discrete or a hybrid combination of the two. We now present a series of examples to illustrate its scope of applications.

**Example `r chapnum`.1.3. Generating Exponential Random Numbers.**
Suppose that we would like to generate observations from an exponential distribution with scale
parameter $\theta$ so that $F(x) = 1 - e^{-x/\theta}$. To compute the
inverse transform, we can use the following steps: 
$$
\begin{aligned}
 y = F(x) &\Leftrightarrow  y = 1-e^{-x/\theta} \\
  &\Leftrightarrow -\theta \ln(1-y) = x = F^{-1}(y) .
\end{aligned}
$$

Thus, if $U$ has a uniform (0,1) distribution, then $X = -\theta \ln(1-U)$ has an exponential distribution with parameter $\theta$.

The following `R` code shows how we can start with the same three uniform random numbers as in *Example 6.1.2* and transform them to independent exponentially distributed random variables with a mean of 10. Alternatively, you can directly use the `rexp` function in `R` to generate random numbers from the exponential distribution. The algorithm built into this routine is different so even with the same starting seed number, individual realizations will differ.

```{r, echo=SHOW_PDF}
set.seed(2017)
U <- runif(3)
X1 <- -10*log(1-U)
set.seed(2017)
X2 <- rexp(3, rate = 1/10)
```

##### Three Uniform Random Variates {-}

```{r echo = FALSE}
outmat <- cbind(U,X1,X2)
colnames(outmat) <- c("Uniform","Exponential 1", "Exponential 2")
knitr::kable(outmat, digits=5)
```


***

**Example `r chapnum`.1.4. Generating Pareto Random Numbers.**
Suppose that we would like to generate observations from a Pareto distribution with parameters $\alpha$ and
$\theta$ so that $F(x) = 1 - \left(\frac{\theta}{x+\theta} \right)^{\alpha}$. To compute
the inverse transform, we can use the following steps: 

$$
\begin{aligned}
 y = F(x) &\Leftrightarrow 1-y = \left(\frac{\theta}{x+\theta} \right)^{\alpha} \\
  &\Leftrightarrow \left(1-y\right)^{-1/\alpha} = \frac{x+\theta}{\theta} = \frac{x}{\theta} +1 \\
    &\Leftrightarrow \theta \left((1-y)^{-1/\alpha} - 1\right) = x = F^{-1}(y) .\end{aligned}
$$
    
Thus, $X = \theta \left((1-U)^{-1/\alpha} - 1\right)$ has a Pareto distribution with parameters $\alpha$ and $\theta$.

***


**Inverse Transform Justification.** Why does the random variable $X = F^{-1}(U)$ have a distribution function $F$?

<h5 style="text-align: center;"><a id="displayTheory.1" href="javascript:toggleTheory('ShowTheory.1','displayTheory.1');"><i><strong>Show A Snippet of Theory</strong></i></a> </h5><div id="ShowTheory.1" style="display: none">

***

This is easy to establish in the continuous case. Because $U$ is a uniform random variable on (0,1), we know that $\Pr(U \le y) = y$, for $0 \le y \le 1$. Thus, 

$$
\begin{aligned}
\Pr(X \le x) &= \Pr(F^{-1}(U) \le x) \\
 &= \Pr(F(F^{-1}(U)) \le F(x)) \\
&= \Pr(U \le F(x)) = F(x)
\end{aligned}
$$

as required. The key step is that $F(F^{-1}(u)) = u$ for each $u$, which is clearly true when $F$ is strictly increasing.

***

</div>

We now consider some discrete examples.

**Example `r chapnum`.1.5. Generating Bernoulli Random Numbers.**
Suppose that we wish to simulate random variables from a Bernoulli distribution with parameter $q=0.85$.

(ref:BinaryDF) **Distribution Function of a Binary Random Variable**

```{r BinaryDF, fig.cap='(ref:BinaryDF)', out.width='50%', fig.asp=.75, fig.align='center', echo=FALSE, cache = TRUE}
time = seq(-1,2,0.01)
Ftime = c(rep(0,100),rep(.85,100),rep(1,101))

plot(time,Ftime, ylim=c(0,1), xlab="x",ylab="",pch=19, cex=.2)#,type="l")
mtext("F(x)", side=2, at=1.1, las=1, cex=1.2, adj=1.6)
segments(0,0,0,0.85)#,code=4)
segments(1,0.85,1,1)#,code=4)
symbols(0,.85,circles=.03, add=TRUE,bg="black",inches=FALSE)
symbols(0,0,circles=.03, add=TRUE,inches=FALSE)
symbols(1,.85,circles=.03, add=TRUE,inches=FALSE)
symbols(1,1,circles=.03, add=TRUE,bg="black",inches=FALSE)
```


A graph of the cumulative distribution function in Figure \@ref(fig:BinaryDF) shows that the quantile function can be written as
$$
\begin{aligned}
F^{-1}(y) = \left\{ \begin{array}{cc}
              0 & 0<y \leq 0.85 \\
              1 & 0.85 < y  \leq  1.0 .
            \end{array} \right.
\end{aligned}
$$

Thus, with the inverse transform we may define 
$$
\begin{aligned}
X = \left\{ \begin{array}{cc}
              0 & 0<U \leq 0.85  \\
              1 &  0.85 < U  \leq  1.0
            \end{array} \right.
\end{aligned}
$$
For illustration, we generate three random numbers to get

```{r, echo=SHOW_PDF}
set.seed(2017)
U <- runif(3)
X <- 1*(U > 0.85)
```
#### Three Random Variates {-}
```{r echo = FALSE}
outmat <- cbind(U,X)
colnames(outmat) <- c("Uniform","Binary X")
knitr::kable(outmat, digits=5)
```

**Example `r chapnum`.1.6. Generating Random Numbers from a Discrete Distribution.**
Consider the time of a machine failure in the first five years. The distribution of failure times is
given as:

##### Discrete Distribution {-}

```{r echo = FALSE, fig.align='center'}
time <- 1:5
probs <- c(0.1,0.2,0.1, 0.4, 0.2)
df <- cumsum(probs)
outmat <- rbind(time, probs, df)
rownames(outmat) <- c("Time","Probability","Distribution Function")
knitr::kable(outmat, align=c('rrrrr'), col.names = rep('',5))
```



(ref:DiscreteDF) **Distribution Function of a Discrete Random Variable**

```{r DiscreteDF, fig.cap='(ref:DiscreteDF)', out.width='60%', fig.asp=.75, fig.align='center', echo=FALSE}
time = seq(0,6,0.01)
Ftime = c(rep(0,100),rep(0.1,100),rep(0.3,100),rep(0.4,100),
          rep(0.8,100),rep(1,101))
plot(time,Ftime, ylim=c(0,1), xlab="x",ylab="",pch=19, cex=.2)#,type="l")
mtext("F(x)", side=2, at=1.1, las=1, cex=1.2, adj=1.6)
segments(1,0,1,0.1)#,code=4)
segments(2,0.1,2,.3)#,code=4)
segments(3,0.3,3,.4)#,code=4)
segments(4,0.4,4,.8)#,code=4)
segments(5,0.8,5,1)#,code=4)

symbols(1,0,circles=.05, add=TRUE,inches=FALSE)
symbols(1,.1,circles=.05, add=TRUE,bg="black",inches=FALSE)
symbols(2,.1,circles=.05, add=TRUE,inches=FALSE)
symbols(2,.3,circles=.05, add=TRUE,bg="black",inches=FALSE)
symbols(3,.3,circles=.05, add=TRUE,inches=FALSE)
symbols(3,.4,circles=.05, add=TRUE,bg="black",inches=FALSE)
symbols(4,.4,circles=.05, add=TRUE,inches=FALSE)
symbols(4,.8,circles=.05, add=TRUE,bg="black",inches=FALSE)
symbols(5,.8,circles=.05, add=TRUE,inches=FALSE)
symbols(5,1,circles=.05, add=TRUE,bg="black",inches=FALSE)
```

Using the graph of the distribution function in Figure \@ref(fig:DiscreteDF), with the inverse transform we may define

$$
\small{
\begin{aligned}
X = \left\{ \begin{array}{cc}
              1 &   0<U  \leq 0.1  \\
              2 &  0.1 < U  \leq  0.3\\
              3 &  0.3 < U  \leq  0.4\\
              4 &  0.4 < U  \leq  0.8  \\
              5 &  0.8 < U  \leq  1.0     .
            \end{array} \right.
\end{aligned}
}
$$

***

For general discrete random variables there may not be an ordering of
outcomes. For example, a person could own one of five types of life
insurance products and we might use the following algorithm to generate
random outcomes: 

$$
{\small
\begin{aligned}
X = \left\{ \begin{array}{cc}
  \textrm{whole life} &   0<U  \leq 0.1  \\
 \textrm{endowment} &  0.1 < U  \leq  0.3\\
\textrm{term life} &  0.3 < U  \leq  0.4\\
  \textrm{universal life} &  0.4 < U  \leq  0.8  \\
  \textrm{variable life} &  0.8 < U  \leq  1.0 .
            \end{array} \right.
\end{aligned}
}
$$ 
            
Another analyst may use an alternative procedure such as: 

$$
{\small
\begin{aligned}
X = \left\{ \begin{array}{cc}
  \textrm{whole life} &   0.9<U<1.0  \\
 \textrm{endowment} &  0.7 \leq U < 0.9\\
\textrm{term life} &  0.6 \leq U < 0.7\\
  \textrm{universal life} &  0.2 \leq U < 0.6  \\
  \textrm{variable life} &  0 \leq U < 0.2 .
            \end{array} \right.
\end{aligned}
}
$$
            
            
Both algorithms produce (in the long-run) the same probabilities, e.g., $\Pr(\textrm{whole life})=0.1$, and so forth. So, neither is incorrect. You should be aware that there is more than one way to accomplish a goal. Similarly, you could use an alternative algorithm for ordered outcomes (such as failure times 1, 2, 3, 4, or 5, above).

**Example `r chapnum`.1.7. Generating Random Numbers from a Hybrid Distribution.**
Consider a random variable that is 0
with probability 70% and is exponentially distributed with parameter
$\theta= 10,000$ with probability 30%. In an insurance application, this might correspond to a 70% chance of having no insurance claims and a 30%
chance of a claim - if a claim occurs, then it is exponentially distributed. The distribution function, depicted in Figure \@ref(fig:MixedDF), is given as

$$
\begin{aligned}
F(y) = \left\{ \begin{array}{cc}
              0 &  x<0  \\
              1 - 0.3 \exp(-x/10000) & x \ge 0 .
            \end{array} \right.
\end{aligned}
$$
      
(ref:MixedDF) **Distribution Function of a Hybrid Random Variable**            

```{r MixedDF, fig.cap='(ref:MixedDF)', out.width='60%', fig.asp=.75, fig.align='center', echo=FALSE}
time = seq(-1000,40000,10)
Ftime = 1 - .3*exp(-0.0001*time)
Ftime = Ftime*(time>0)
plot(time,Ftime, ylim=c(0,1), xlab="x",ylab="",pch=19, cex=.2)#,xaxt="n")
#axis(1, at=seq(0,40000, by=10000), font=10, cex=0.005, tck=0.01)
mtext("F(x)", side=2, at=1.1, las=1, cex=1.2, adj=1.6)
segments(0,0,0,0.7)#,code=4)
symbols(0,0,circles=500, add=TRUE,inches=FALSE)
symbols(0,.7,circles=500, add=TRUE,bg="black",inches=FALSE)
```


From Figure \@ref(fig:MixedDF), we can see that the inverse transform for generating random variables with this distribution function is

$$
\begin{aligned}
X = F^{-1}(U) = \left\{ \begin{array}{cc}
              0 &  0< U  \leq  0.7  \\
              -1000 \ln (\frac{1-U}{0.3}) & 0.7 < U < 1 .
            \end{array} \right.
\end{aligned}
$$

For discrete and hybrid random variables, the key is to draw a graph of the distribution function that allows you to visualize potential values of the inverse function.

### Simulation Precision

From the prior subsections, we now know how to generate independent simulated realizations from a distribution of interest. With these realizations, we can construct an empirical distribution and approximate the underlying distribution as precisely as needed. As we introduce more actuarial applications in this book, you will see that simulation can be applied in a wide variety of contexts.

Many of these applications can be reduced to the problem of approximating $\mathrm{E~}[h(X)]$, where $h(\cdot)$
is some known function.  Based on $R$ simulations (replications), we get $X_1,\ldots,X_R$. From this simulated sample, we calculate an average 

$$
\overline{h}_R=\frac{1}{R}\sum_{i=1}^{R} h(X_i)
$$
that we use as our simulated approximate (estimate) of $\mathrm{E~}[h(X)]$. To estimate the precision of this approximation, we use the simulation variance

$$
s_{h,R}^2 = \frac{1}{R-1} \sum_{i=1}^{R}\left( h(X_i) -\overline{h}_R
\right) ^2.
$$

From the independence, the standard error of the estimate is $s_{h,R}/\sqrt{R}$. This can be made as small as we like by increasing the number of replications $R$.


```{r warning=FALSE, message=FALSE, comment="", echo=FALSE}
# For the gamma distributions, use
alpha1 <- 2;      theta1 <- 100
alpha2 <- 2;      theta2 <- 200
# Deductibles
M <- 400

nSim <- 1e6  #number of simulations
```

**Example `r chapnum`.1.8. Portfolio Management.** 
In Section \@ref(S:CoverageModifications), we learned how to calculate the expected value of policies with deductibles. For an example of something that cannot be done with closed form expressions, we now consider two risks. This is a variation of a more complex example that will be covered as *Example 10.3.6*.

We consider two property risks of a telecommunications firm:

- $X_1$ - buildings, modeled using a gamma distribution with mean `r alpha1*theta1` and scale parameter `r theta1`.
- $X_2$ - motor vehicles, modeled using a gamma distribution with mean `r alpha2*theta2` and scale parameter `r theta2`.

Denote the total risk as $X = X_1 + X_2.$ For simplicity, you assume that these risks are independent. 

To manage the risk, you seek some insurance protection. You are willing to retain internally small building and motor vehicles amounts, up to $M$, say. Random amounts in excess of $M$ will have an unpredictable affect on your budget and so for these amounts you seek insurance protection. Stated mathematically, your retained risk is $Y_{retained}=$ $\min(X_1 + X_2,M)$ and the insurer's portion is $Y_{insurer} =  X- Y_{retained}$.

To be specific, we use $M=$ `r M` as well as $R=$ `r nSim` simulations. 

**a.** With the settings, we wish to determine the expected claim amount and the associated standard deviation of (i) that retained, (ii) that accepted by the insurer, and (iii) the total overall amount.

`r HideRCode('PortMgt1.8.1', 'Show R Code to Define the Risks')`

```{r warning=FALSE, message=FALSE, fig.width=8, fig.height=4, fig.align='center', comment="", echo=SHOW_PDF}

# Simulate the risks
nSim <- 1e6  #number of simulations
set.seed(2017) #set seed to reproduce work 
X1 <- rgamma(nSim,alpha1,scale = theta1)  
X2 <- rgamma(nSim,alpha2,scale = theta2)  

# Portfolio Risks
X         <- X1 + X2 
Yretained <- pmin(X, M)
Yinsurer  <- X - Yretained
```

</div>

Here is the code for the expected claim amounts.

`r HideRCode('PortMgt1.8.2', 'Show R Code To Compute Amounts')`

```{r warning=FALSE, message=FALSE, fig.width=8, fig.height=4, fig.align='center', comment="", echo=SHOW_PDF}
# Expected Claim Amounts
ExpVec <- t(as.matrix(c(mean(Yretained),mean(Yinsurer),mean(X))))
sdVec <- t(as.matrix(c(sd(Yretained),sd(Yinsurer),sd(X))))
outMat <- rbind(ExpVec, sdVec)
colnames(outMat) <- c("Retained", "Insurer","Total")
row.names(outMat) <- c("Mean","Standard Deviation")
round(outMat,digits=2)
```

</div>

The results of these calculations are:

```{r warning=FALSE, message=FALSE, fig.width=8, fig.height=4, fig.align='center', comment="", echo=SHOW_PDF}
round(outMat,digits=2)
```


**b.** For insured claims, the standard error of the simulation approximation is $s_{h,R}/\sqrt{1000000} =$ `r 
round(sd(Yinsurer),digits=2)` $/\sqrt{1000000} =$  `r round(sd(Yinsurer)/sqrt(1000000), digits=3)`. For this example, simulation is quick and so a large value such as 1000000 is an easy choice. However, for more complex problems, the simulation size may be an issue. 

`r HideRCode('PortMgt1.8.3', 'Show R Code To Set up the Visualization')`

```{r warning=FALSE, message=FALSE, fig.width=8, fig.height=4, fig.align='center', comment="", echo=SHOW_PDF}
Yinsurefct <- function(numSim){
X1 <- rgamma(numSim,alpha1,scale = theta1)  
X2 <- rgamma(numSim,alpha2,scale = theta2)  
# Portfolio Risks
X         <- X1 + X2 
Yinsurer <- X - pmin(X, M)
return(Yinsurer)
}
R <- 1e3
nPath <- 20
set.seed(2017)
simU <- matrix(Yinsurefct(R*nPath),R,nPath)
sumP2 <- apply(simU, 2, cumsum)/(1:R)
```

</div>

Figure \@ref(fig:PortfolioDF) allows us to visualize the development of the approximation as the number of simulations increases.

(ref:PortfolioDF) **Estimated Expected Insurer Claims versus Number of Simulations**

```{r PortfolioDF, warning=FALSE, message=FALSE, fig.width=8, fig.height=4, fig.align='center', comment="", fig.cap = '(ref:PortfolioDF)', echo=SHOW_PDF}
matplot(1:R,sumP2[,1:20],type="l",col=rgb(1,0,0,.2), ylim=c(100, 400),
        xlab=expression(paste("Number of Simulations (", italic('R'), ")")), 
        ylab="Expected Insurer Claims")
abline(h=mean(Yinsurer),lty=2)
bonds <- cbind(1.96*sd(Yinsurer)*sqrt(1/(1:R)),-1.96*sd(Yinsurer)*sqrt(1/(1:R)))
matlines(1:R,bonds+mean(Yinsurer),col="red",lty=1)
```

***

**Determination of Number of Simulations**

How many simulated values are recommended? 100? 1,000,000? We can use the `r Gloss('central limit theorem', '6.1')` to respond to this question. 

As one criterion for your confidence in the result, suppose that you wish to be within 1% of the mean with 95%
certainty. That is, you want $\Pr \left( |\overline{h}_R - \mathrm{E~}[h(X)]| \le 0.01 \mathrm{E~}[h(X)] \right) \ge 0.95$. According to the central limit theorem, your estimate should be approximately normally distributed and so we want to have $R$ large enough to satisfy $0.01 \mathrm{E~}[h(X)]/\sqrt{\mathrm{Var~}[h(X)]/R}) \ge 1.96$. (Recall that 1.96 is the 97.5th percentile from the standard normal distribution.) Replacing $\mathrm{E~}[h(X)]$ and $\mathrm{Var~}[h(X)]$ with estimates, you continue your simulation until 

$$
\frac{.01\overline{h}_R}{s_{h,R}/\sqrt{R}}\geq 1.96
$$
or equivalently 

\begin{equation}
R \geq 38,416\frac{s_{h,R}^2}{\overline{h}_R^2}.
(\#eq:NumSimulations)
\end{equation}


This criterion is a direct application of the approximate normality. Note that $\overline{h}_R$ and $s_{h,R}$ are not known in
advance, so you will have to come up with estimates, either by doing a small pilot study in advance or by interrupting your procedure intermittently to see if the criterion is satisfied.


**Example `r chapnum`.1.8. Portfolio Management - continued** 

For our example, the average insurance claim is `r round(mean(Yinsurer), digits=3)` and the corresponding standard deviation is `r round(sd(Yinsurer), digits=3)`. Using equation \@ref(eq:NumSimulations), to be within 10% of the mean, we would only require at least `r round(38416*(sd(Yinsurer)/mean(Yinsurer))^2/1000,digits=2)` thousand simulations. However, to be within 1% we would want at least `r round(100*38416*(sd(Yinsurer)/mean(Yinsurer))^2/1000000,digits=2)` million simulations.

***

**Example `r chapnum`.1.9. Approximation Choices.** 
An important application of simulation is the approximation of $\mathrm{E~}[h(X)]$. In this example, we show that the choice of the $h(\cdot)$ function and the distribution of $X$ can play a role.

Consider the following question : what is $\Pr[X>2]$ when $X$ has a `r Gloss('Cauchy distribution')`, with density $f(x) =\left(\pi(1+x^2)\right)^{-1}$, on the real line? The true value is 

$$
\Pr\left[X>2\right] = \int_2^\infty \frac{dx}{\pi(1+x^2)} .
$$
One can use an `R` numerical integration function (which usually works well on improper integrals)

```{r, echo=SHOW_PDF}
true_value <- integrate(function(x) 1/(pi*(1+x^2)),lower=2,upper=Inf)$value
```
which is equal to `r round(true_value,digits=5)`.

**Approximation 1.** Alternatively, one can use simulation techniques to approximate that quantity. From calculus, you can check that the quantile function of the Cauchy distribution is $F^{-1}(y) = \tan \left( \pi(y-0.5) \right)$. Then, with simulated uniform (0,1) variates, $U_1, \ldots, U_R$, we can construct the estimator

$$
p_1 = \frac{1}{R}\sum_{i=1}^R \mathrm{I}(F^{-1}(U_i)>2) = \frac{1}{R}\sum_{i=1}^R \mathrm{I}(\tan \left( \pi(U_i-0.5) \right)>2) .
$$

`r HideRCode('Approximationchoices.1.9.1', 'Show the R Code')`

```{r comment = "", echo=SHOW_PDF}
Q <- function(u) tan(pi*(u-.5))
R <- 1e6
set.seed(1)
X <- Q(runif(R))
p1 <- mean(X>2)
se.p1 <- sd(X>2)/sqrt(R)
p1
se.p1
```

</div>

With one million simulations, we obtain an estimate of `r round(p1,digits=5)` with standard error `r round(se.p1*1000,digits=3)` (divided by 1000). One can prove that the variance of $p_1$ is of order $0.127/R$.

<!--It can be visualized below -->
```{r eval=FALSE, echo = FALSE}
true_value <- integrate(function(x) 1/(pi*(1+x^2)),lower=2,upper=Inf)$value
n <- 1e3
ns <- 20
set.seed(1)
simU <- matrix(Q(runif(n*ns))>2,n,ns)
sumP1 <- apply(simU, 2, cumsum)/(1:n)
matplot(1:n,sumP1[,1:20],type="l",col=rgb(1,0,0,.2),ylim=c(.1,.2),
        xlab="Number of simulations (n)",ylab="Approximation of the integral")
abline(h=true_value,lty=2)
bonds <- cbind(1.96*sqrt(.127/(1:n)),-1.96*sqrt(.127/(1:n)))
matlines(1:n,bonds+true_value,col="red",lty=1)
```

**Approximation 2.** With other choices of $h(\cdot)$ and $F(\cdot)$ it is possible to reduce uncertainty even using the same number of simulations $R$. To begin, one can use the symmetry of the Cauchy distribution to write $\Pr[X>2]=0.5\cdot\Pr[|X|>2]$. With this, can construct a new estimator,

$$
p_2 = \frac{1}{2R}\sum_{i=1}^R \mathrm{I}(|F^{-1}(U_i)|>2) .
$$


```{r echo = FALSE}
set.seed(1)
p2 <- mean(abs(Q(runif(R)))>2)/2
se.p2 <- sd(abs(Q(runif(R)))>2)/(2*sqrt(R))
```

With one million simulations, we obtain an estimate of `r round(p2,digits=5)` with standard error `r round(se.p2*1000,digits=3)` (divided by 1000). One can prove that the variance of $p_2$ is of order $0.052/R$.

<!--It can be visualized below -->
```{r eval=FALSE, echo = FALSE}
n <- 1e3
ns <- 20
set.seed(1)
simU <- matrix(abs(Q(runif(n*ns)))>2,n,ns)
sumP2 <- apply(simU, 2, cumsum)/(1:n)/2
matplot(1:n,sumP2[,1:20],type="l",col=rgb(1,0,0,.2),ylim=c(.1,.2),
        xlab="Number of simulations (n)",ylab="Approximation of the integral")
abline(h=true_value,lty=2)
bonds <- cbind(1.96*sqrt(.052/(1:n)),-1.96*sqrt(.052/(1:n)))
matlines(1:n,bonds+true_value,col="red",lty=1)
```

**Approximation 3.** But one can go one step further. The improper integral can be written as a proper one by a simple symmetry property (since the function is symmetric and the integral on the real line is equal to $1$)
$$
\int_2^\infty \frac{dx}{\pi(1+x^2)}=\frac{1}{2}-\int_0^2\frac{dx}{\pi(1+x^2)} .
$$
From this expression, a natural approximation would be
$$
p_3 = \frac{1}{2}-\frac{1}{R}\sum_{i=1}^R h_3(2U_i), ~~~~~~\text{where}~h_3(x)=\frac{2}{\pi(1+x^2)} .
$$
```{r echo = FALSE}
h <- function(x) 2/(pi*(1+x^2))
set.seed(1)
p3 <- .5-mean(h(2*runif(R)))
se.p3 <- sd(h(2*runif(R)))/sqrt(R)
```

With one million simulations, we obtain an estimate of `r round(p3,digits=5)` 
with standard error `r signif(se.p3*1000,digits=3)` (divided by 1000).  One can prove that the variance of $p_3$ is of order $0.0285/R$.

<!--It can be visualized below -->
```{r eval=FALSE, echo = FALSE}
n <- 1e3
ns <- 20
set.seed(1)
simU <- matrix((h(2*runif(n*ns))),n,ns)
sumP3 <- .5-apply(simU, 2, cumsum)/(1:n)
matplot(1:n,sumP3[,1:20],type="l",col=rgb(1,0,0,.2),ylim=c(.1,.2),
        xlab="Number of simulations (n)",ylab="Approximation of the integral")
abline(h=true_value,lty=2)
bonds <- cbind(1.96*sqrt(.0285/(1:n)),-1.96*sqrt(.0285/(1:n)))
matlines(1:n,bonds+true_value,col="red",lty=1)
```

**Approximation 4.** Finally, one can also consider some change of variable in the integral
$$
\int_2^\infty \frac{dx}{\pi(1+x^2)}=\int_0^{1/2}\frac{y^{-2}dy}{\pi(1-y^{-2})} .
$$
From this expression, a natural approximation would be
$$
p_4 = \frac{1}{R}\sum_{i=1}^R h_4(U_i/2),~~~~~\text{where}~h_4(x)=\frac{1}{2\pi(1+x^2)} .
$$
The expression seems rather similar to the previous one. 

```{r echo = FALSE}
set.seed(1)
h4 <- function(x) 1/(2*pi*(1+x^2))
p4 <- mean(h4(runif(R)/2))
se.p4 <- sd(h4(runif(R)/2))/sqrt(R)
```

With one million simulations, we obtain an estimate of `r round(p4,digits=5)` with standard error `r round(se.p4*1000,digits=3)` (divided by 1000). One can prove that the variance of $p_4$ is of order $0.00009/R$, which is much smaller than what we had so far!

<!--It can be visualized below -->
```{r eval=FALSE, echo = FALSE}
n <- 1e3
ns <- 20
set.seed(1)
simU <- matrix((h(runif(n*ns)/2)),n,ns)
sumP4 <- apply(simU, 2, cumsum)/(1:n)
matplot(1:n,sumP4[,1:20],type="l",col=rgb(1,0,0,.2),ylim=c(.1,.2),
        xlab="Number of simulations (n)",ylab="Approximation of the integral")
abline(h=true_value,lty=2)
bonds <- cbind(1.96*sqrt(.00009/(1:n)),-1.96*sqrt(.00009/(1:n)))
matlines(1:n,bonds+true_value,col="red",lty=1)
```

[Table 6.1] summarizes the four choices of $h(\cdot)$ and $F(\cdot)$ to approximate $\Pr[X>2] =$ `r round(true_value,digits=5)`. The standard error varies dramatically. Thus, if we have a desired degree of accuracy, then the *number of simulations* depends strongly on how we write the integrals we try to approximate.


[Table 6.1]:\#tab:61

<a id=tab:61></a>

Table 6.1. **Summary of Four Choices to Approximate** $\Pr[X>2]$

<div align="center">
```{r echo = FALSE, message=FALSE, warning=FALSE}
library(htmlTable)
library(knitr)
library(kableExtra)
x1 <- c(
  "$p_1$", 
  "$\\frac{1}{R}\\sum_{i=1}^R \\mathrm{I}(F^{-1}(U_i)>2)$",
   "$~~~~~~F^{-1}(u)=\\tan \\left( \\pi(u-0.5) \\right)~~~~~~~$",round(c(p1,se.p1),digits=6))
x2 <- c(
  "$p_2$", 
  "$\\frac{1}{2R}\\sum_{i=1}^R \\mathrm{I}(|F^{-1}(U_i)|>2)$",
   "$F^{-1}(u)=\\tan \\left( \\pi(u-0.5) \\right)$",round(c(p2,se.p2),digits=6))
x3 <- c(
  "$p_3$", 
  "$\\frac{1}{2}-\\frac{1}{R}\\sum_{i=1}^R h_3(2U_i)$",
"$h_3(x)=\\frac{2}{\\pi(1+x^2)}$",round(c(p3,se.p3),digits=6))
x4 <- c(
  "$p_4$", 
  "$\\frac{1}{R}\\sum_{i=1}^R h_4(U_i/2)$",
  "$h_4(x)=\\frac{1}{2\\pi(1+x^2)}$",format(round(c(p4,se.p4),digits=6), scientific = FALSE))
outMat <- rbind(x1,x2,x3,x4)
rownames(outMat) <- NULL
# htmlTable(outMat, header =  c("Estimator", "Definition",
#                             "Support Function", "Estimate", " Standard Error"),
#           align = "cccrr")  
colnames(outMat) <- c("Estimator", "Definition",
                            "Support \n Function", "Estimate", " Standard \n Error")
if (knitr::is_latex_output()) {knitr::kable(outMat, "latex", booktabs=TRUE, escape = F, align = "cccrr") %>%
  kable_styling(font_size = 10, latex_options="scale_down")
}
if (knitr::is_html_output()) {knitr::kable(outMat, "html", booktabs=TRUE, escape = F, align = "cccrr") %>%
  kable_styling(bootstrap_options = c("striped", "hover", "condensed", "responsive"),
          font_size = 10)
  }
```
</div>


### Simulation and Statistical Inference {#S:SimulationStatInference}

Simulations not only help us approximate expected values but are also useful in calculating other aspects of distribution functions. In particular, they are very useful when distributions of test statistics are too complicated to derive; in this case, one can use simulations to approximate the reference distribution. We now illustrate this with the `r Gloss("Kolmogorov-Smirnov test")` that we learned about in Section \@ref(S:MS:Tools:Stats). 


**Example `r chapnum`.1.10. Kolmogorov-Smirnov Test of Distribution.** 
Suppose that we have available $n=100$ observations $\{x_1,\cdots,x_n\}$ that, unknown to the analyst, were generated from a gamma distribution with parameters $\alpha = 6$ and $\theta=2$. The analyst believes that the data come from a lognormal distribution with parameters 1 and 0.4 and would like to test this assumption.

The first step is to visualize the data. 

`r HideRCode('KSTest.1.10.1','Show R Code To Set up The Visualization')`

```{r fig.align='center', comment="", echo=SHOW_PDF}
set.seed(1)
n <- 100
x <- rgamma(n, 6, 2)

u=seq(0,7,by=.01)
vx = c(0,sort(x))
vy = (0:n)/n
```

</div>

With this set-up, Figure \@ref(fig:KSTestData) provides a graph of a histogram and empirical distribution. For reference, superimposed are red dashed lines from the lognormal distribution. 

(ref:KSTestData) **Histogram and Empirical Distribution Function of Data used in Kolmogorov-Smirnov Test**. The red dashed lines are fits based on (incorrectly) hypothesized lognormal distribution.

```{r KSTestData, fig.align='center', comment="", fig.cap = '(ref:KSTestData)', echo=SHOW_PDF}
par(mfrow=c(1,2))
hist(x,probability = TRUE,main="Histogram", col="light blue",
     border="white",xlim=c(0,7),ylim=c(0,.4))
lines(u,dlnorm(u,1,.4),col="red",lty=2)
plot(vx,vy,type="l",xlab="x",ylab="Cumulative Distribution",main="Empirical cdf")
lines(u,plnorm(u,1,.4),col="red",lty=2)
```

Recall that the Kolmogorov-Smirnov statistic equals the largest discrepancy between the empirical and the hypothesized distribution. This is $\max_x |F_n(x)-F_0(x)|$, where $F_0$ is the hypothesized lognormal distribution. We can calculate this directly as:

`r HideRCode('KSTest.1.10.2','Show R Code for a Direct Calculation of the KS Statistic')`

```{r comment="", echo=SHOW_PDF}
# test statistic
D <- function(data, F0){
   F <- Vectorize(function(x) mean((data<=x)))
   n <- length(data)
   x <- sort(data)
   d1=abs(F(x+1e-6)-F0(x+1e-6))
   d2=abs(F(x-1e-6)-F0(x-1e-6))
   return(max(c(d1,d2)))
}
D(x,function(x) plnorm(x,1,.4))
```

</div>

Fortunately, for the lognormal distribution, `R` has built-in tests that allow us to determine this without complex programming:

```{r comment="", echo=SHOW_PDF}
ks.test(x, plnorm, mean=1, sd=0.4)
```


However, for many distributions of actuarial interest, pre-built programs are not available. We can use simulation to test the relevance of the test statistic. Specifically, to compute the $p$-value, let us generate thousands of random samples from a $LN(1,0.4)$ distribution (with the same size), and compute empirically the distribution of the statistic,

`r HideRCode('KSTest.1.10.3','Show R Code for the Simulation Distribution of the KS Statistic')`

```{r fig.align='center', comment="", cho=SHOW_PDF}
ns <- 1e4
d_KS <- rep(NA,ns)
# compute the test statistics for a large (ns) number of simulated samples
for(s in 1:ns) d_KS[s] <- D(rlnorm(n,1,.4),function(x) plnorm(x,1,.4))

mean(d_KS>D(x,function(x) plnorm(x,1,.4)))
```

</div>

(ref:KSSimulatedDistribution) **Simulated Distribution of the Kolmogorov-Smirnov Test Statistic**. The vertical red dashed line marks the test statistic for the sample of 100.

```{r KSSimulatedDistribution, fig.align='center', comment="", fig.cap = '(ref:KSSimulatedDistribution)', echo=SHOW_PDF}
hist(d_KS,probability = TRUE,col="light blue",border="white",xlab="Test Statistic",main="")
lines(density(d_KS),col="red")
abline(v=D(x,function(x) plnorm(x,1,.4)),lty=2,col="red")

```


The simulated distribution based on 10,000 random samples is summarized in Figure \@ref(fig:KSSimulatedDistribution). Here, the statistic exceeded the empirical value (`r format(D(x,function(x) plnorm(x,1,.4)),digits=4)`) in `r 100*mean(d_KS>D(x,function(x) plnorm(x,1,.4)))`% of the scenarios, while the *theoretical* $p$-value is `r round(ks.test(x,plnorm,mean=1,sd=.4)$p.value, digits=4)`. For both the simulation and the theoretical $p$-values, the conclusions are the same; the data do not provide sufficient evidence to reject the hypothesis of a lognormal distribution.


Although only an approximation, the simulation approach works in a variety of distributions and test statistics without needing to develop the nuances of the underpinning theory for each situation. We summarize the procedure for developing simulated distributions and *p*-values as follows:

1. Draw a sample of size *n*, say, $X_1, \ldots, X_n$, from a known distribution function $F$. Compute a statistic of interest, denoted as $\hat{\theta}(X_1, \ldots, X_n)$. Call this $\hat{\theta}^r$ for the *r*th replication.
2. Repeat this $r=1, \ldots, R$ times to get a sample of statistics, $\hat{\theta}^1, \ldots,\hat{\theta}^R$.
3. From the sample of statistics in Step 2, $\{\hat{\theta}^1, \ldots,\hat{\theta}^R\}$, compute a summary measure of interest, such as a *p*-value.



## Bootstrapping and Resampling {#S:Bootstrap}

***
In this section, you learn how to:

-   Generate a nonparametric bootstrap distribution for a statistic of interest
-   Use the bootstrap distribution to generate estimates of precision for the statistic of interest, including bias, standard deviations, and confidence intervals
-   Perform bootstrap analyses for parametric distributions

***

<!--  Bootstrap -->

### Bootstrap Foundations

Simulation presented up to now is based on sampling from a **known** distribution. Section \@ref(S:SimulationFundamentals) showed how to use simulation techniques to sample and compute quantities from known distributions.  However, statistical  science is dedicated to providing inferences about distributions that are *unknown*. We gather summary statistics based on this unknown population distribution. But how do we sample from an unknown distribution? 

Naturally, we cannot simulate draws from an unknown distribution but we can draw from a sample of observations. If the sample is a good representation from the population, then our simulated draws from the sample should well approximate the simulated draws from a population. The process of sampling from a sample is called *resampling* or *bootstrapping*. The term `r Gloss('bootstrap')` comes from the phrase "pulling oneself up by one's bootstraps" (Efron, 1979). With resampling, the original sample plays the role of the population and estimates from the sample play the role of true population parameters.

The resampling algorithm is the same as introduced in Section \@ref(S:SimulationStatInference) except that now we use simulated draws from a sample. It is common to use $\{X_1, \ldots, X_n\}$ to denote the original sample and let $\{X_1^*, \ldots, X_n^*\}$ denote the simulated draws. We draw them with replacement so that the simulated draws will be independent from one another, the same assumption as with the original sample. For each sample, we also use *n* simulated draws, the same number as the original sample size. To distinguish this procedure from the simulation, it is common to use *B* (for bootstrap) to be the number of simulated samples. We could also write $\{X_1^{(b)}, \ldots, X_n^{(b)}\}$, $b=1,\ldots, B$ to clarify this.

There are two basic resampling methods, *model-free* and *model-based*, which are, respectively, as *nonparametric* and *parametric*. In the `r Gloss('nonparametric approach')`, no assumption is made about the distribution of the parent population. The simulated draws come from the empirical distribution function $F_n(\cdot)$, so each draw comes from $\{X_1, \ldots, X_n\}$ with probability 1/*n*. 

In contrast, for the `r Gloss('parametric approach')`, we assume that we have knowledge of the distribution family *F*. The original sample $X_1, \ldots, X_n$ is used to estimate parameters of that family, say, $\hat{\theta}$. Then, simulated draws are taken from the $F(\hat{\theta})$. Section \@ref(S:ParametricBootStrap) discusses this approach in further detail.


#### Nonparametric Bootstrap {-}

The idea of the nonparametric bootstrap is to use the inverse transform method on $F_n$, the empirical cumulative distribution function, depicted in Figure \@ref(fig:InverseDFboot).

(ref:InverseDFboot) **Inverse of an Empirical Distribution Function**

```{r InverseDFboot, fig.cap='(ref:InverseDFboot)', out.width='60%', fig.asp=.75, fig.align='center', echo=FALSE, cache = TRUE}
plot.new()
par(cex=1.3)
set.seed(1)
x <- sort(c(0,rexp(10, 1/6)))
y<- (0:10)/10
plot(x,y, xlim=c(0, 10), ylim=c(0, 1), lwd=2,
        xlab="", type="s", ylab="",xaxs="i", yaxs="i", xaxt="n", yaxt="n")
vx <- seq(0, 10, by=.01)
vy<- 1-exp(-vx/6)
lines(vx,vy,lty=2,col="red")
x.6 <- x[9]
y.6 <- (sum(x<x.6))/10-.03
mtext("y=F(x)", side=2, line=2, cex=1.3, las=2, padj=-4, adj=.5) # TO MOVE UPWARD
axis(1, at=x.6, labels=expression("x =" ~ F^{-1} *"(y)"))
segments(x.6,0,x.6,y.6)
segments(0,y.6,x.6,y.6)
axis(1, at=0)
axis(2, at=0)
```

Because $F_n$ is a step-function, $F_n^{-1}$ takes values in $\{x_1,\cdots,x_n\}$. More precisely, as illustrated in Figure \@ref(fig:InverseDFboot2).

- if $y\in(0,1/n)$ (with probability $1/n$) we draw the smallest value ($\min\{x_i\}$)
- if $y\in(1/n,2/n)$ (with probability $1/n$) we draw the second smallest value,
- ...
- if $y\in((n-1)/n,1)$ (with probability $1/n$) we draw the largest value ($\max\{x_i\}$).

(ref:InverseDFboot2) **Inverse of an Empirical Distribution Function**

```{r InverseDFboot2, fig.cap='(ref:InverseDFboot2)', out.width='60%', fig.asp=.75, fig.align='center', echo=FALSE, cache = TRUE}
plot.new()
par(cex=1.3)
set.seed(1)
x <- sort(c(0,rexp(10, 1/6)))
y<- (0:10)/10
plot(x,y, xlim=c(0, 10), ylim=c(0, 1), lwd=2,
        xlab="", type="s", ylab="",xaxs="i", yaxs="i", xaxt="n", yaxt="n")
vx <- seq(0, 10, by=.01)
clr <- c(rgb(0,1,0,.2),rgb(0,0,1,.2))
for(i in 1:10){
  rect(-10,(i-1)/10,100,i/10,col=clr[1+i%%2],border="white")
}
abline(v=x,col="white")
lines(x,y,lwd=2,type="s")
vy<- 1-exp(-vx/6)
lines(vx,vy,lty=2,col="red")
```

Using the inverse transform method with $F_n$ means sampling from $\{x_1,\cdots,x_n\}$, with probability $1/n$. Generating a bootstrap sample of size $B$ means sampling from $\{x_1,\cdots,x_n\}$, with probability $1/n$, with replacement. See the following illustrative `R` code.


`r HideRCode('BootStrap.A','Show R Code For Creating a Bootstrap Sample')`

```{r comment="", echo=SHOW_PDF}
set.seed(1)
n <- 10
x <- rexp(n, 1/6)
m <- 8
bootvalues <- sample(x, size=m, replace=TRUE)
```

</div>

```{r comment="", echo=FALSE}
round(bootvalues,digits=4)
```

Observe that value `r round(x[4],digits=4)` was obtained three times.



### Bootstrap Precision: Bias, Standard Deviation, and Mean Square Error {#S:Sim:Precision}


We summarize the nonparametric bootstrap procedure as follows:

1. From the sample $\{X_1, \ldots, X_n\}$, draw a sample of size *n* (with replacement), say, $X_1^*, \ldots, X_n^*$. From the simulated draws compute a statistic of interest, denoted as $\hat{\theta}(X_1^*, \ldots, X_n^*)$. Call this $\hat{\theta}_b^*$ for the *b*th replicate.
2. Repeat this $b=1, \ldots, B$ times to get a sample of statistics, $\hat{\theta}_1^*, \ldots,\hat{\theta}_B^*$.
3. From the sample of statistics in Step 2, $\{\hat{\theta}_1^*, \ldots, \hat{\theta}_B^*\}$, compute a summary measure of interest.
 
In this section, we focus on three summary measures, the `r Gloss('bias')`, the standard deviation, and the mean square error (*MSE*). [Table 6.2] summarizes these three measures. Here, $\overline{\hat{\theta^*}}$ is the average of $\{\hat{\theta}_1^*, \ldots,\hat{\theta}_B^*\}$.


[Table 6.2]:\#tab:62

<a id=tab:62></a>

Table 6.2. **Bootstrap Summary Measures**

$$
{\small
\begin{matrix}
\begin{array}{l|c|c|c}
\hline
\text{Population Measure}& \text{Population Definition}&\text{Bootstrap Approximation}&\text{Bootstrap Symbol}\\
\hline
\text{Bias} & \mathrm{E}(\hat{\theta})-\theta&\overline{\hat{\theta^*}}-\hat{\theta}& Bias_{boot}(\hat{\theta})  \\\hline
\text{Standard Deviation} &   \sqrt{\mathrm{Var}(\hat{\theta})}
& \sqrt{\frac{1}{B-1} \sum_{b=1}^{B}\left(\hat{\theta}_b^* -\overline{\hat{\theta^*}} \right) ^2}&s_{boot}(\hat{\theta})  \\\hline
\text{Mean Square Error} &\mathrm{E}(\hat{\theta}-\theta)^2 & \frac{1}{B} \sum_{b=1}^{B}\left(\hat{\theta}_b^* -\hat{\theta}
\right)^2&MSE_{boot}(\hat{\theta})\\
\hline
\end{array}\end{matrix}
}
$$



***

**Example `r chapnum`.2.1. Bodily Injury Claims and Loss Elimination Ratios.** To show how the bootstrap can be used to quantify the precision of estimators, we return to the Section \@ref(S:MS:PlugIn) Example 4.1.6 bodily injury claims data where we introduced a nonparametric estimator of the loss elimination ratio.

[Table 6.3] summarizes the results of the bootstrap estimation. For example, at $d=14000$, the nonparametric estimate of *LER* is 0.97678. This has an estimated bias of 0.00018 with a standard deviation of 0.00701. For some applications, you may wish to apply the estimated bias to the original estimate to give a `r Gloss('bias-corrected estimator')`. This is the focus of the next example. For this illustration, the bias is small and so such a correction is not relevant.


`r HideRCode('LER6.2.1','Show R Code For Bootstrap Estimates of LER')`

```{r comment="", warning=FALSE, echo=SHOW_PDF}
# Example from Derrig et al
BIData <- read.csv("Data/DerrigResampling.csv", header =T)
BIData$Censored <- 1*(BIData$AmountPaid >= BIData$PolicyLimit)
BIDataUncensored <- subset(BIData, Censored == 0)
LER.boot <- function(ded, data, indices){
  resample.data <- data[indices,]
  sumClaims <- sum(resample.data$AmountPaid)
  sumClaims_d <- sum(pmin(resample.data$AmountPaid,ded))
  LER <-   sumClaims_d/sumClaims
  return(LER)  
}

##Derrig et al
set.seed(2019)
dVec2 <- c(4000, 5000, 10500, 11500, 14000, 18500)
OutBoot <- matrix(0,length(dVec2),6)
  for (i in 1:length(dVec2)) {
OutBoot[i,1] <- dVec2[i]
results <- boot(data=BIDataUncensored, statistic=LER.boot, R=1000, ded=dVec2[i])
OutBoot[i,2] <- results$t0
biasboot <- mean(results$t)-results$t0 -> OutBoot[i,3]
sdboot <- sd(results$t) -> OutBoot[i,4]
temp <- boot.ci(results)
OutBoot[i,5] <- temp$normal[2]
OutBoot[i,6] <- temp$normal[3]
}
```

</div>

[Table 6.3]:\#tab:63

<a id=tab:63></a>

Table 6.3. **Bootstrap Estimates of LER at Selected Deductibles**

```{r comment="", echo=FALSE}
OutBoot.latex <- OutBoot
colnames(OutBoot) <- c("d","NP Estimate","Bootstrap Bias", "Bootstrap SD", 
                           "Lower Normal 95% CI", "Upper Normal 95% CI")
if (knitr::is_html_output()) {knitr::kable(OutBoot, "html",digits=5) %>%
  kable_styling(bootstrap_options = c("striped", "hover", "condensed", "responsive"),
          font_size = 10)
}
if (knitr::is_latex_output()) {knitr::kable(OutBoot.latex, "latex", booktabs = T, digits=5) %>%
  kable_styling(latex_options="scale_down") %>%
    add_header_above(c("","Estimate","Bias", "SD", 
                           "95% CI", "95% CI"))  %>%
      add_header_above(c("d","NP","Bootstrap", "Bootstrap", 
                           "Lower Normal", "Upper Normal"))
}
```




The bootstrap standard deviation gives a measure of precision. For one application of standard deviations, we can use the normal approximation to create a confidence interval. For example, the `R` function `boot.ci` produces the normal confidence intervals at 95%. These are produced by creating an interval of twice the length of 1.95994 bootstrap standard deviations, centered about the bias-corrected estimator (1.95994 is the 97.5th quantile of the standard normal distribution). For example, the lower normal 95% CI at $d=14000$ is $(0.97678-0.00018)- 1.95994*0.00701$ $= 0.96286$. We further discuss bootstrap confidence intervals in the next section.

***

**Example `r chapnum`.2.2. Estimating $\exp(\mu)$.** 
The bootstrap can be used to quantify the bias of an estimator, for instance. Consider here a sample $\mathbf{x}=\{x_1,\cdots,x_n\}$ that is `r Gloss('iid')` with mean $\mu$.

```{r comment="", echo=SHOW_PDF}
sample_x <- c(2.46,2.80,3.28,3.86,2.85,3.67,3.37,3.40,5.22,2.55,
              2.79,4.50,3.37,2.88,1.44,2.56,2.00,2.07,2.19,1.77)
```

Suppose that the quantity of interest is $\theta=\exp(\mu)$. A natural estimator would be $\widehat{\theta}_1=\exp(\overline{x})$. This estimator is biased (due to the `r Gloss('Jensen inequality')`) but is asymptotically unbiased. For our sample, the estimate is as follows.

```{r comment="", echo=SHOW_PDF}
(theta_1 <- exp(mean(sample_x)))
```

One can use the central limit theorem to get a correction using
$$
\overline{X}\approx\mathcal{N}\left(\mu,\frac{\sigma^2}{n}\right)\text{ where }\sigma^2=\text{Var}[X_i] ,
$$
so that, with the normal moment generating function, we have
$$
\mathrm{E}~\left[\exp(\overline{X})\right] \approx \exp\left(\mu+\frac{\sigma^2}{2n}\right) .
$$
Hence, one can consider naturally
$$
\widehat{\theta}_2=\exp\left(\overline{x}-\frac{\widehat{\sigma}^2}{2n}\right) .
$$
For our data, this turns out to be as follows.

```{r comment="", echo=SHOW_PDF}
n <- length(sample_x)
(theta_2 <- exp(mean(sample_x)-var(sample_x)/(2*n)))
```

As another strategy (that we do not pursue here), one can also use Taylor's approximation to get a more accurate estimator (as in the delta method),
$$
g(\overline{x})=g(\mu)+(\overline{x}-\mu)g'(\mu)+(\overline{x}-\mu)^2\frac{g''(\mu)}{2}+\cdots
$$
The alternative we do explore is to use a bootstrap strategy: given a bootstrap sample, $\mathbf{x}^{\ast}_{b}$, let $\overline{x}^{\ast}_{b}$ denote its mean, and set

$$
\widehat{\theta}_3=\frac{1}{B}\sum_{b=1}^B\exp(\overline{x}^{\ast}_{b}) .
$$
To implement this, we have the following code.

`r HideRCode('bootstrapdisn.1','Show R Code for Creating Bootstrap Samples')`

```{r comment="", echo=SHOW_PDF}
library(boot)
results <- boot(data=sample_x, 
                statistic=function(y,indices) exp(mean(y[indices])), 
                R=1000)
theta_3 <- mean(results$t)
```

</div>

Then, you can `plot(results)` and `print(results)` to see the following.

(ref:BootstrapDistn) **Distribution of Bootstrap Replicates**. The left-hand panel is a histogram of replicates. The right-hand panel is a quantile-quantile plot, comparing the bootstrap distribution to the standard normal distribution.

```{r BootstrapDistn, fig.cap='(ref:BootstrapDistn)', fig.align='center',  comment="", echo=FALSE}
plot(results)
print(results)
```

This results in three estimators, the raw estimator $\widehat{\theta}_1=$ `r round(theta_1,digits=3)`, the second-order correction $\widehat{\theta}_2=$ `r round(theta_2,digits=3)`, and the bootstrap estimator $\widehat{\theta}_3=$ `r round(theta_3,digits=3)`.

How does this work with differing sample sizes? We now suppose that the $x_i$'s are generated from a lognormal distribution $LN(0,1)$, so that $\mu = \exp(0 + 1/2) = 1.648721$ and $\theta = \exp(1.648721)$ $= 5.200326$. We use simulation to draw the sample sizes but then act as if they were a realized set of observations. See the following illustrative code.

`r HideRCode('bootstrapdisn.2','Show R Code for Creating Bootstrap Samples')`

```{r  comment="", echo=SHOW_PDF}
param <- function(x){
  n <- length(x)
  theta_1 <- exp(mean(x))
  theta_2 <- exp(mean(x)-var(x)/(2*n))
  results <- boot(data=x, 
                statistic=function(y,indices) exp(mean(y[indices])), 
                R=999)
  theta_3 <- mean(results$t)
  return(c(theta_1,theta_2,theta_3))
}
set.seed(2074)
ns<- 200
est <- function(n){
call_param <- function(i) param(rlnorm(n,0,1))
V <- Vectorize(call_param)(1:ns)
apply(V,1,median)
}
VN=seq(15,100,by=5)
Est <- Vectorize(est)(VN)

```

</div>

The results of the comparison are summarized in Figure \@ref(fig:BootstrapCompare). This figure shows that the bootstrap estimator is closer to the true parameter value for almost all sample sizes. The bias of  all three estimators decreases as the sample size increases.

(ref:BootstrapCompare) **Comparision of Estimates.** True value of the parameter is given by the solid horizontal line at 5.20.

```{r BootstrapCompare, fig.cap='(ref:BootstrapCompare)', fig.align='center',  comment="", echo=SHOW_PDF, cache = TRUE}
matplot(VN,t(Est),type="l", col=2:4, lty=2:4, ylim=exp(exp(1/2))+c(-1,1),
        xlab="sample size (n)", ylab="estimator")
abline(h=exp(exp(1/2)),lty=1, col=1)
legend("topleft", c("raw estimator", "second order correction", "bootstrap"),
       col=2:4,lty=2:4, bty="n")
```

### Confidence Intervals

The bootstrap procedure generates *B* replicates $\hat{\theta}_1^*, \ldots,\hat{\theta}_B^*$ of the estimator $\hat{\theta}$. In *Example `r chapnum`.2.1,* we saw how to use standard normal approximations to create a confidence interval for parameters of interest. However, given that a major point is to use bootstrapping to avoid relying on assumptions of approximate normality, it is not surprising that there are alternative confidence intervals available.

For an estimator $\hat{\theta}$, the *basic* bootstrap confidence interval is

\begin{equation} 
  \left(2 \hat{\theta} - q_U, 2 \hat{\theta} - q_L \right) ,
(\#eq:basicBootCI)
\end{equation}

where $q_L$ and $q_U$ are lower and upper 2.5% quantiles from the bootstrap sample $\hat{\theta}_1^*, \ldots,\hat{\theta}_B^*$.

To see where this comes from, start with the idea that $(q_L, q_U)$ provides a 95% interval for $\hat{\theta}_1^*, \ldots,\hat{\theta}_B^*$. So, for a random $\hat{\theta}_b^*$, there is a 95% chance that $q_L \le \hat{\theta}_b^* \le q_U$. Reversing the inequalities and adding $\hat{\theta}$ to each side gives a 95% interval 

$$
\hat{\theta} -q_U \le \hat{\theta} - \hat{\theta}_b^* \le  \hat{\theta} -q_L .
$$
So, $\left( \hat{\theta}-q_U,  \hat{\theta} -q_L\right)$ is an 95% interval for $\hat{\theta} - \hat{\theta}_b^*$. The bootstrap approximation idea says that this is also a 95% interval for $\theta - \hat{\theta}$. Adding $\hat{\theta}$ to each side gives the 95% interval in equation \@ref(eq:basicBootCI). 

Many alternative bootstrap intervals are available. The easiest to explain is the `r Gloss('percentile bootstrap interval')` which is defined as $\left(q_L, q_U\right)$. However, this has the drawback of potentially poor behavior in the tails which can be of concern in some actuarial problems of interest.


**Example `r chapnum`.2.3. Bodily Injury Claims and Risk Measures.** To see how the bootstrap confidence intervals work, we return to the bodily injury auto claims considered in *Example 6.2.1*. Instead of the loss elimination ratio, suppose we wish to estimate the 95th percentile $F^{-1}(0.95)$ and a measure defined as
$$
TVaR_{0.95}[X] = \mathrm{E}[X | X > F^{-1}(0.95)] .
$$
This measure is called the `r Gloss('tail value-at-risk')`; it is the expected value of $X$ conditional on $X$ exceeding the 95th percentile. Section \@ref(S:Tails) explains how quantiles and the tail value-at-risk are the two most important examples of so-called *risk measures*. For now, we will simply think of these as measures that we wish to estimate. For the percentile, we use the nonparametric estimator $F^{-1}_n(0.95)$ defined in Section \@ref(S:MS:QuantileEstimator). For the tail value-at-risk, we use the plug-in principle to define the nonparametric estimator

$$
TVaR_{n,0.95}[X] = \frac{\sum_{i=1}^n X_i I(X_i > F^{-1}_n(0.95))}{\sum_{i=1}^n I(X_i > F^{-1}_n(0.95))} ~.
$$
In this expression, the denominator counts the number of observations that exceed the 95th percentile $F^{-1}_n(0.95)$. The numerator adds up losses for those observations that exceed $F^{-1}_n(0.95)$. [Table 6.4] summarizes the estimator for selected fractions.


`r HideRCode('bootstrapquantiles.1','Show R Code for Creating Quantile Bootstrap Samples')`

```{r comment="", warning=FALSE, echo=SHOW_PDF}
# Example from Derrig et al
#BIData <- read.csv("Data/DerrigResampling.csv", header =T)
BIData$Censored <- 1*(BIData$AmountPaid >= BIData$PolicyLimit)
BIDataUncensored <- subset(BIData, Censored == 0)

set.seed(2017)
PercentVec <- c(0.50, 0.80, 0.90, 0.95, 0.98)
OutBoot1 <- matrix(0,5,10)
for (i in 1:length(PercentVec)) {
OutBoot1[i,1] <- PercentVec[i]
results <- boot(data=BIDataUncensored$AmountPaid,
                statistic=function(X,indices)
                    quantile(X[indices],PercentVec[i]),
                 R=1000)
if (i==1){bootreal <- results$t}
OutBoot1[i,2] <- results$t0
OutBoot1[i,3] <- mean(results$t)-results$t0 
OutBoot1[i,4] <- sd(results$t) 
temp <- boot.ci(results, type = c("norm", "basic", "perc"))
OutBoot1[i,5] <- temp$normal[2]
OutBoot1[i,6] <- temp$normal[3]
OutBoot1[i,7] <- temp$basic[4]
OutBoot1[i,8] <- temp$basic[5]
OutBoot1[i,9] <- temp$percent[4]
OutBoot1[i,10] <- temp$percent[5]
}

```

</div>

[Table 6.4]:\#tab:64

<a id=tab:64></a>

Table 6.4. **Bootstrap Estimates of Quantiles at Selected Fractions**

```{r comment="", echo=FALSE}
OutBoot1.latex <- OutBoot1
colnames(OutBoot1) <- c("Fraction","NP Estimate", "Bootstrap Bias", 
       "Bootstrap SD", "Lower Normal 95% CI", "Upper Normal  95% CI",
       "Lower Basic 95% CI", "Upper Basic 95% CI",
       "Lower Percentile 95% CI", "Upper  Percentile 95% CI")
if (knitr::is_html_output()) {knitr::kable(OutBoot1, "html",digits=2) %>%
  kable_styling(bootstrap_options = c("striped", "hover", "condensed", "responsive"),
          font_size = 10)
}
if (knitr::is_latex_output()) {knitr::kable(OutBoot1.latex, booktabs = T, "latex",digits=2) %>%
  kable_styling(latex_options="scale_down") %>%
    add_header_above(c("","Estimate", "Bias", 
       "SD", "95% CI", "95% CI",
       "95% CI", "95% CI",
       "95% CI", "95% CI")) %>%
    add_header_above(c("Fraction","NP", "Bootstrap", 
       "Bootstrap", "Lower Normal", "Upper Normal",
       "Lower Basic", "Upper Basic",
       "Lower Percentile", "Upper  Percentile"))
  }
```



For example, when the fraction is 0.50, we see that lower and upper 2.5th quantiles of the bootstrap simulations are $q_L=$ `r quantile(bootreal,.025, type=6)` and $q_u=$ `r quantile(bootreal,.975, type=6)`, respectively. These form the percentile bootstrap confidence interval. With the nonparametric estimator `r quantile(BIDataUncensored$AmountPaid,.5)`, these yield the lower and upper bounds of the basic confidence interval `r 2*quantile(BIDataUncensored$AmountPaid,.5)-quantile(bootreal,.975, type=6)`
and `r 2*quantile(BIDataUncensored$AmountPaid,.5)-quantile(bootreal,.025, type=6)`, respectively. [Table 6.4] also shows bootstrap estimates of the bias, standard deviation, and a normal confidence interval, concepts introduced in Section \@ref(S:Sim:Precision).


[Table 6.5] shows similar calculations for the tail value-at-risk. In each case, we see that the bootstrap standard deviation increases as the fraction increases. This is because there are fewer observations to estimate quantiles as the fraction increases, leading to greater imprecision.  Confidence intervals also become wider. Interestingly, there does not seem to be the same pattern in the estimates of the bias.


`r HideRCode('bootstrapquantiles.2','Show R Code for Creating TVar Bootstrap Samples')`

```{r comment="", warning=FALSE, echo=SHOW_PDF}

CTE.boot <- function(data, indices, RiskLevel){
  resample.data <- data[indices,]
  X <- resample.data$AmountPaid
  cutoff <- quantile(X, RiskLevel)
  CTE <- sum(X*(X > cutoff))/sum(X > cutoff)
  return(CTE) 
}

set.seed(2017)  
PercentVec <- c(0.50, 0.80, 0.90, 0.95, 0.98)
OutBoot1 <- matrix(0,5,10)
  for (i in 1:length(PercentVec)) {
OutBoot1[i,1] <- PercentVec[i]
results <- boot(data=BIDataUncensored, statistic=CTE.boot, R=1000, RiskLevel=PercentVec[i])
OutBoot1[i,2] <- results$t0
OutBoot1[i,3] <- mean(results$t)-results$t0 
OutBoot1[i,4] <- sd(results$t) 
temp <- boot.ci(results, type = c("norm", "basic", "perc"))
OutBoot1[i,5] <- temp$normal[2]
OutBoot1[i,6] <- temp$normal[3]
OutBoot1[i,7] <- temp$basic[4]
OutBoot1[i,8] <- temp$basic[5]
OutBoot1[i,9] <- temp$percent[4]
OutBoot1[i,10] <- temp$percent[5]
  }

```

</div>

[Table 6.5]:\#tab:65

<a id=tab:65></a>

Table 6.5. **Bootstrap Estimates of TVaR at Selected Risk Levels**


```{r comment="", echo=FALSE}
OutBoot1.latex <- OutBoot1
colnames(OutBoot1) <- c("Fraction","NP Estimate", "Bootstrap Bias", 
       "Bootstrap SD", "Lower Normal 95% CI", "Upper Normal  95% CI",
       "Lower Basic 95% CI", "Upper Basic 95% CI",
       "Lower Percentile 95% CI", "Upper  Percentile 95% CI")
if (knitr::is_html_output()) {knitr::kable(OutBoot1, "html",digits=2) %>%
  kable_styling(bootstrap_options = c("striped", "hover", "condensed", "responsive"),
          font_size = 10)
}
if (knitr::is_latex_output()) {knitr::kable(OutBoot1.latex, "latex", booktabs = T, digits=2) %>%
  kable_styling(latex_options="scale_down") %>%
    add_header_above(c("","Estimate", "Bias", 
       "SD", "95% CI", "95% CI",
       "95% CI", "95% CI",
       "95% CI", "95% CI"))  %>%
    add_header_above(c("Fraction","NP", "Bootstrap", 
       "Bootstrap", "Lower Normal", "Upper Normal",
       "Lower Basic", "Upper Basic",
       "Lower Percentile", "Upper  Percentile"))
  }
```



### Parametric Bootstrap {#S:ParametricBootStrap}

The idea of the nonparametric bootstrap is to resample  by drawing independent variables from the empirical cumulative distribution function $F_n$. In contrast, with parametric bootstrap, we draw independent variables from $F_{\widehat{\theta}}$ where the underlying distribution is assumed to be in a parametric family $\mathcal{F}=\{F_{\theta},\theta\in\Theta\}$. Typically, parameters from this distribution are estimated based on a sample and denoted as $\hat{\theta}$.

**Example `r chapnum`.2.4. Lognormal distribution.** Consider again the dataset  
```{r, echo=SHOW_PDF}
sample_x <- c(2.46,2.80,3.28,3.86,2.85,3.67,3.37,3.40,
              5.22,2.55,2.79,4.50,3.37,2.88,1.44,2.56,2.00,2.07,2.19,1.77)

```

The classical (nonparametric) bootstrap was based on the following samples.

```{r, echo=SHOW_PDF}
x <- sample(sample_x,replace=TRUE)

```

Instead, for the parametric bootstrap, we have to assume that the distribution of $x_i$'s is from a specific family. As an example, the following code utilizes a lognormal distribution.

```{r comment="", warning=FALSE, echo=SHOW_PDF}
library(MASS)
fit <- fitdistr(sample_x, dlnorm, list(meanlog = 1, sdlog = 1))
fit

```

Then we draw from that distribution.

```{r,echo=SHOW_PDF}
x <- rlnorm(length(sample_x), meanlog=fit$estimate[1], sdlog=fit$estimate[2])
```


`r HideRCode('BootTVar.1','Show R Code for Parametric Bootstrap Samples')`

```{r comment="",echo=SHOW_PDF}
set.seed(2074)
CV <- matrix(NA,1e5,2)
for(s in 1:nrow(CV)){
x1 <- sample(sample_x,replace=TRUE)
x2 <- rlnorm(length(sample_x), meanlog=fit$estimate[1], sdlog=fit$estimate[2])
CV[s,] <- c(sd(x1)/mean(x1),sd(x2)/mean(x2))
}

```

</div>

Figure \@ref(fig:CoefVarCompare) compares the bootstrap distributions for the coefficient of variation, one based on the nonparametric approach and the other based on a parametric approach, assuming a lognormal distribution.

(ref:CoefVarCompare) **Comparision of Nonparametric and Parametric Bootstrap Distributions for the Coefficient of Variation**

```{r CoefVarCompare, fig.cap='(ref:CoefVarCompare)', fig.align='center',  comment="", echo=SHOW_PDF, cache = TRUE}
plot(density(CV[,1]),col="red",main="",xlab="Coefficient of Variation", lty=1)
lines(density(CV[,2]),col="blue",lty=2)
abline(v=sd(sample_x)/mean(sample_x),lty=3)
legend("topright",c("nonparametric","parametric(LN)"),
       col=c("red","blue"),lty=1:2,bty="n")
```

***

**Example `r chapnum`.2.5. Bootstrapping Censored Observations.** The parametric bootstrap draws simulated realizations from a parametric estimate of the distribution function. In the same way, we can draw simulated realizations from estimates of a distribution function. As one example, we might draw from smoothed estimates of a distribution function introduced in Section \@ref(S:MS:Density). Another special case, considered here, is to draw an estimate from the Kaplan-Meier estimator introduced in Section \@ref(S:MS:RightCensored). In this way, we can handle observations that are censored.

Specifically, return to the bodily injury data in Examples 6.2.1 and 6.2.3 but now we include the `r sum(BIData$Censored)` claims that were censored by policy limits. In Example 4.3.6, we used this full dataset to estimate the Kaplan-Meier estimator of the survival function introduced in Section \@ref(S:MS:RightCensored). [Table 6.6] presents bootstrap estimates of the quantiles from the Kaplan-Meier survival function estimator. These include the bootstrap precision estimates, bias and standard deviation, as well as the basic 95% confidence interval.


`r HideRCode('KMCode.1','Show R Code For Bootstrap Kaplan-Meier Estimates')`

```{r comment="", warning=FALSE,echo=SHOW_PDF}
# Example from Derrig et al
library(survival)                # for Surv(), survfit()
BIData$UnCensored <- 1*(BIData$AmountPaid < BIData$PolicyLimit)
## KM estimate
KM0 <- survfit(Surv(AmountPaid, UnCensored) ~ 1,  
               type="kaplan-meier", data=BIData)

set.seed(2019)
PercentVec <- c(0.50, 0.80, 0.90, 0.95, 0.98)
OutBoot1 <- matrix(NA,5,6)
KM.survobj <- Surv(BIData$AmountPaid, BIData$UnCensored) 
for (i in 1:length(PercentVec)) {
OutBoot1[i,1] <- PercentVec[i]
results <- bootkm(KM.survobj, q=1-PercentVec[i], B=1000, pr = FALSE)
if (i==1){bootreal <- results}
OutBoot1[i,2] <- quantile(KM0, PercentVec[i])$quantile
OutBoot1[i,3] <- mean(results)-OutBoot1[i,2]
OutBoot1[i,4] <- sd(results) 
# temp <- boot.ci(results, type = c("norm",  "basic","perc"))
OutBoot1[i,5] <- 2*OutBoot1[i,2]-quantile(results,.975, type=6)
OutBoot1[i,6] <- 2*OutBoot1[i,2]-quantile(results,.025, type=6)
}

```

</div>

[Table 6.6]:\#tab:66

<a id=tab:66></a>

Table 6.6. **Bootstrap Kaplan-Meier Estimates of Quantiles at Selected Fractions**


```{r comment="", echo=FALSE}
OutBoot1.latex <- OutBoot1
colnames(OutBoot1) <- c("Fraction","KM NP Estimate", "Bootstrap Bias",
                        "Bootstrap SD",  "Lower Basic 95% CI", "Upper Basic 95% CI")
if (knitr::is_html_output()) {knitr::kable(OutBoot1, "html",digits=2) %>%
  kable_styling(bootstrap_options = c("striped", "hover", "condensed", "responsive"),
          font_size = 10)
}
if (knitr::is_latex_output()) {knitr::kable(OutBoot1.latex, "latex", booktabs = T, digits=2) %>%
  kable_styling(latex_options="scale_down") %>%
        add_header_above(c("","Estimate", "Bias",
                      "SD",  "95% CI", "95% CI")) %>%
    add_header_above(c("Fraction","KM NP", "Bootstrap ",
                      "Bootstrap",  "Lower Basic", "Upper Basic"))

}
```



Results in [Table 6.6] are consistent with the results for the uncensored subsample in [Table 6.4]. In [Table 6.6], we note the difficulty in estimating quantiles at large fractions due to the censoring. However, for moderate size fractions (0.50, 0.80, and 0.90), the Kaplan-Meier nonparametric (KM NP) estimates of the quantile are consistent with those [Table 6.4]. The bootstrap standard deviation is smaller at the 0.50 (corresponding to the median) but larger at the 0.80 and 0.90 levels. The censored data analysis summarized in [Table 6.6] uses more data than the uncensored subsample analysis in [Table 6.4] but also has difficulty extracting information for large quantiles.



## Cross-Validation {#S:CrossValidation}

In this section, you learn how to:

-  Compare and contrast cross-validation to simulation techniques and bootstrap methods.
-  Use cross-validation techniques for model selection
-  Explain the jackknife method as a special case of cross-validation and calculate jackknife estimates of bias and standard errors

***

<!-- ## Cross-Validation -->

Cross-validation, briefly introduced in Section \@ref(S:MS:Cross-Validation), is a technique based on simulated outcomes.  We now compare and contrast cross-validation to other simulation techniques already introduced in this chapter."

- Simulation, or Monte-Carlo, introduced in Section \@ref(S:SimulationFundamentals), allows us to compute expected values and other summaries of statistical distributions, such as $p$-values, readily.
- Bootstrap, and other resampling methods introduced in Section \@ref(S:Bootstrap), provides estimators of the precision, or variability, of statistics.
- Cross-validation is important when assessing how accurately a predictive model will perform in practice.

Overlap exists but nonetheless it is helpful to think about the broad goals associated with each statistical method.

To discuss cross-validation, let us recall from Section \@ref(S:MS:ModelSelection) some of the key ideas of model validation. When assessing, or validating, a model, we look to  performance measured on *new* data, or at least not those that were used to fit the model. A classical approach, described in Section 4.2.3, is to split the sample in two: a subpart (the *training* dataset) is used to fit the model and the other one (the *testing* dataset) is used to validate. However, a limitation of this approach is that results depend on the split; even though the overall sample is fixed, the split between training and test subsamples varies randomly. A different training sample means that model estimated parameters will differ. Different model parameters and a different test sample means that validation statistics will differ. Two analysts may use the same data and same models yet reach different conclusions about the viability of a model (based on different random splits), a frustrating situation.

<!-- 
Cross-validation techniques are used to avoid the basic two part split. Note that two techniques will be mentioned here : an exhaustive approach, where all observations will be used (once, and only once) as a testing observation and a non-exhaustive one, based on bootstrap techniques. See [Arlot & Celisse (2010)](https://projecteuclid.org/euclid.ssu/1268143839) for a survey.
 -->

### k-Fold Cross-Validation

To mitigate this difficulty, it is common to use a cross-validation approach as introduced in Section 4.2.4. The key idea is to emulate the basic test/training approach to model validation by repeating it many times through averaging over different splits of the data. A key advantage is that the validation statistic is not tied to a specific parametric (or nonparametric) model - one can use a nonparametric statistic or a statistic that has economic interpretations - and so this can be used to compare models that are not nested (unlike likelihood ratio procedures).

```{r echo = FALSE, warning = FALSE, message = FALSE, comment = ""}
## Read in data and get number of claims.  
claim_lev <- read.csv("Data/CLAIMLEVEL.csv", header = TRUE) 
# 2010 subset 
claim_data <- subset(claim_lev, Year == 2010); 
library(MASS)
library(VGAM)
library(goftest)
# Fit a Pareto distribution to the full dataset
fit.pareto <- vglm(Claim ~ 1, paretoII, loc = 0, data = claim_data)
ksResultPareto <- ks.test(claim_data$Claim, "pparetoII", loc = 0, shape = exp(coef(fit.pareto)[2]), 
        scale = exp(coef(fit.pareto)[1]))
# Fit a gamma distribution to the full dataset
fit.gamma <- glm(Claim ~ 1, data = claim_data, family = Gamma(link = log)) 
gamma_theta <- exp(coef(fit.gamma)) * gamma.dispersion(fit.gamma) 
alpha <- 1 / gamma.dispersion(fit.gamma)
ksResultGamma <- ks.test(claim_data$Claim, "pgamma", shape = alpha, scale = gamma_theta)

```

**Example `r chapnum`.3.1. Wisconsin Property Fund.** For the 2010 property fund data introduced in Section \@ref(S:LGPIF), we fit gamma and Pareto distributions to the 1,377 claims data. For details of the related goodness of fit, see Appendix Section 15.4.4. We now consider the Kolmogorov-Smirnov statistic introduced in Section \@ref(S:MS:Tools:Stats). When the entire dataset was fit, the Kolmogorov-Smirnov goodness of fit statistic for the gamma distribution turns out to be `r round(ksResultGamma$statistic,digits=4)` and for the Pareto distribution is `r round(ksResultPareto$statistic,digits=4)`. The lower value for the Pareto distribution indicates that this distribution is a better fit than the gamma.

To see how `r Gloss('k-fold cross-validation')` works, we randomly split the data into $k=8$ groups, or folds, each having about $1377/8 \approx 172$ observations. Then, we fit gamma and Pareto models to a data set with the first seven folds (about $172 \cdot 7 = 1204$ observations), determine estimated parameters, and then used these fitted models with the held-out data to determine the Kolmogorov-Smirnov statistic. 

`r HideRCode('KFoldCV.1','Show R Code for Kolmogorov-Smirnov Cross-Validation')`

```{r warning = FALSE, message = FALSE, comment = "",  echo=SHOW_PDF}
# Randomly re-order the data - "shuffle it"
n <- nrow(claim_data)
set.seed(12347)
cvdata <- claim_data[sample(n), ]
# Number of folds
k <- 8
cvalvec <- matrix(0,2,k)
for (i in 1:k) {
  indices <- (((i-1) * round((1/k)*nrow(cvdata))) + 1):((i*round((1/k) * nrow(cvdata))))
# Pareto
  fit.pareto <- vglm(Claim ~ 1, paretoII, loc = 0, data = cvdata[-indices,])
  ksResultPareto <- ks.test(cvdata[indices,]$Claim, "pparetoII", loc = 0, shape = exp(coef(fit.pareto)[2]), 
        scale = exp(coef(fit.pareto)[1]))
  cvalvec[1,i] <- ksResultPareto$statistic
# Gamma
  fit.gamma <- glm(Claim ~ 1, data = cvdata[-indices,], family = Gamma(link = log)) 
  gamma_theta <- exp(coef(fit.gamma)) * gamma.dispersion(fit.gamma)  
  alpha <- 1 / gamma.dispersion(fit.gamma)
  ksResultGamma <- ks.test(cvdata[indices,]$Claim, "pgamma", shape = alpha, scale = gamma_theta)
  cvalvec[2,i] <- ksResultGamma$statistic
}
KScv <- rowSums(cvalvec)/k

```

</div>

The results appear in Figure \@ref(fig:KScvFig) where horizontal axis is Fold=1. This process was repeated for the other seven folds. The results summarized in Figure \@ref(fig:KScvFig) show that the Pareto consistently provides a more reliable predictive distribution than the gamma.

(ref:KScvFig) **Cross Validated Kolmogorov-Smirnov (KS) Statistics for the Property Fund Claims Data.** The solid black line is for the Pareto distribution, the green dashed line is for the gamma distribution. The KS statistic measures the largest deviation between the fitted distribution and the empirical distribution for each of 8 groups, or folds, of randomly selected data.

```{r KScvFig, warning = FALSE, message = FALSE, comment = "", fig.align='center', fig.cap='(ref:KScvFig)', echo=SHOW_PDF, cache = TRUE}
# Plot the statistics
matplot(1:k,t(cvalvec),type="b", col=c(1,3), lty=1:2, 
        ylim=c(0,0.4), pch = 0, xlab="Fold", ylab="KS Statistic")
legend("left", c("Pareto", "Gamma"), col=c(1,3),lty=1:2, bty="n")
```

### Leave-One-Out Cross-Validation

A special case where $k=n$ is known as `r Gloss('leave-one-out cross validation')`. This case is historically prominent and is closely related to `r Gloss('jackknife statistics')`, a precursor of the bootstrap technique. 

Even though we present it as a special case of cross-validation, it is helpful to given an explicit definition. Consider a generic statistic $\widehat{\theta}=t(\boldsymbol{x})$ that is an estimator for a parameter of interest $\theta$. The idea of the jackknife is to compute $n$ values $\widehat{\theta}_{-i}=t(\boldsymbol{x}_{-i})$, where $\boldsymbol{x}_{-i}$ is the subsample of $\boldsymbol{x}$ with the $i$-th value removed. The average of these values is denoted as
$$
\overline{\widehat{\theta}}_{(\cdot)}=\frac{1}{n}\sum_{i=1}^n \widehat{\theta}_{-i} .
$$
These values can be used to create estimates of the bias of the statistic $\widehat{\theta}$

\begin{equation}
Bias_{jack} = (n-1) \left(\overline{\widehat{\theta}}_{(\cdot)} - \widehat{\theta}\right)
(\#eq:Biasjack)
\end{equation}

as well as a standard deviation estimate

\begin{equation}
s_{jack} =\sqrt{\frac{n-1}{n}\sum_{i=1}^n \left(\widehat{\theta}_{-i} -\overline{\widehat{\theta}}_{(\cdot)}\right)^2} ~.
(\#eq:sdjack)
\end{equation}


**Example `r chapnum`.3.2. Coefficient of Variation.** To illustrate, consider a small fictitious sample $\boldsymbol{x}=\{x_1,\ldots,x_n\}$ with realizations

```{}
sample_x <- c(2.46,2.80,3.28,3.86,2.85,3.67,3.37,3.40,
              5.22,2.55,2.79,4.50,3.37,2.88,1.44,2.56,2.00,2.07,2.19,1.77)
```

Suppose that we are interested in the `r Gloss('coefficient of variation')`
$\theta = CV = \sqrt{\mathrm{Var~}[X]}/\mathrm{E~}[X]$.


```{r echo = FALSE}
sample_x <- c(2.46,2.80,3.28,3.86,2.85,3.67,3.37,3.40,5.22,2.55,2.79,4.50,3.37,2.88,1.44,2.56,2.00,2.07,2.19,1.77)
CVar <- function(x) sqrt(var(x))/mean(x)
JackCVar <- function(i) sqrt(var(sample_x[-i]))/mean(sample_x[-i])
JackTheta <- Vectorize(JackCVar)(1:length(sample_x))
BiasJack <- (length(sample_x)-1)*(mean(JackTheta) - CVar(sample_x))
sdJack <- sd(JackTheta)
```

With this dataset, the estimator of the coefficient of variation turns out to be `r round(CVar(sample_x),digits = 5)`. But how reliable is it? To answer this question, we can compute the jackknife estimates of bias and its standard deviation. The following code shows that the jackknife estimator of the bias is $Bias_{jack} =$ `r round(BiasJack,digits = 5)` and the jackknife standard deviation is $s_{jack} =$ `r round(sdJack,digits = 5)`.


```{r eval = FALSE, echo=SHOW_PDF}
CVar <- function(x) sqrt(var(x))/mean(x)
JackCVar <- function(i) sqrt(var(sample_x[-i]))/mean(sample_x[-i])
JackTheta <- Vectorize(JackCVar)(1:length(sample_x))
BiasJack <- (length(sample_x)-1)*(mean(JackTheta) - CVar(sample_x))
sd(JackTheta)
```

***


**Example `r chapnum`.3.3. Bodily Injury Claims and Loss Elimination Ratios.** In Example `r chapnum`.2.1, we showed how to compute bootstrap estimates of the bias and standard deviation for the loss elimination ratio using the Example 4.1.11 bodily injury claims data. We follow up now by providing comparable quantities using jackknife statistics.

[Table 6.7] summarizes the results of the jackknife estimation. It shows that jackknife estimates of the bias and standard deviation of the loss elimination ratio $\mathrm{E}~[\min(X,d)]/\mathrm{E}~[X]$ are largely consistent with the bootstrap methodology. Moreover, one can use the standard deviations to construct normal based confidence intervals, centered around a bias-corrected estimator. For example, at $d=14000$, we saw in Example 4.1.11 that the nonparametric estimate of *LER* is 0.97678. This has an estimated bias of 0.00010, resulting in the (jackknife) *bias-corrected* estimator 0.97688. The 95% confidence intervals are produced by creating an interval of twice the length of 1.96 jackknife standard deviations, centered about the bias-corrected estimator (1.96 is the approximate 97.5th quantile of the standard normal distribution). 


`r HideRCode('Jackknife.1','Show the R Code')`

```{r comment="", warning=FALSE, echo=SHOW_PDF}
# Example from Derrig et al
BIData <- read.csv("Data/DerrigResampling.csv", header =T)
BIData$Censored <- 1*(BIData$AmountPaid >= BIData$PolicyLimit)
BIDataUncensored <- subset(BIData, Censored == 0)
LER.boot <- function(ded, data, indices){
  resample.data <- data[indices,]
  sumClaims <- sum(resample.data$AmountPaid)
  sumClaims_d <- sum(pmin(resample.data$AmountPaid,ded))
  LER <-   sumClaims_d/sumClaims
  return(LER)  
}

x <- BIDataUncensored$AmountPaid
LER.jack<- function(ded,i){
  LER <-   sum(pmin(x[-i],ded))/sum(x[-i])
  return(LER)  
}
LER <- function(ded) sum(pmin(x,ded))/sum(x)
##Derrig et al
set.seed(2019)
dVec2 <- c(4000, 5000, 10500, 11500, 14000, 18500)
OutJack <- matrix(0,length(dVec2),8)
  for (j in 1:length(dVec2)) {
OutJack[j,1] <- dVec2[j]
results <- boot(data=BIDataUncensored, statistic=LER.boot, R=1000, ded=dVec2[j])
OutJack[j,2] <- results$t0
biasboot <- mean(results$t)-results$t0 -> OutJack[j,3]
sdboot <- sd(results$t) -> OutJack[j,4]
temp <- boot.ci(results)

LER.jack.ded<- function(i) LER.jack(ded=dVec2[j],i)
JackTheta.ded <- Vectorize(LER.jack.ded)(1:length(x))
OutJack[j,5] <- BiasJack.ded <- (length(x)-1)*(mean(JackTheta.ded) - LER(ded=dVec2[j]))
OutJack[j,6] <- sd(JackTheta.ded)
OutJack[j,7:8] <- mean(JackTheta.ded)+qt(c(0.025,0.975),length(x)-1)*OutJack[j,6]
}

```

</div>


[Table 6.7]:\#tab:67

<a id=tab:67></a>

Table 6.7. **Jackknife Estimates of LER at Selected Deductibles**


```{r comment="", echo=FALSE}
OutJack.latex <- OutJack
colnames(OutJack) <- c("d","NP Estimate","Bootstrap Bias", "Bootstrap SD", 
                       "Jackknife Bias", "Jackknife SD","Lower Jackknife 95% CI", "Upper Jackknife 95% CI")
if (knitr::is_html_output()) {knitr::kable(OutJack, "html",digits=5) %>%
  kable_styling(bootstrap_options = c("striped", "hover", "condensed", "responsive"),
          font_size = 10)
}
if (knitr::is_latex_output()) {knitr::kable(OutJack.latex, "latex", booktabs = T, digits=5) %>%
  kable_styling(latex_options="scale_down") %>%
    add_header_above(c("","Estimate","Bias", "SD", 
                       "Bias", "SD","95% CI", "95% CI")) %>%
      add_header_above(c("d","NP","Bootstrap", "Bootstrap", 
                       "Jackknife", "Jackknife","Lower Jackknife", "Upper Jackknife"))
}
```


***

**Discussion.** One of the many interesting things about the leave-one-out special case is the ability to replicate estimates exactly. That is, when the size of the fold is only one, then there is no additional uncertainty induced by the cross-validation. This means that analysts can exactly replicate work of one another, an important consideration.

Jackknife statistics were developed to understand precision of estimators, producing estimators of bias and standard deviation in equations \@ref(eq:Biasjack) and \@ref(eq:sdjack). This crosses into goals that we have associated with bootstrap techniques, not cross-validation methods. This demonstrates how statistical techniques can be used to achieve different goals.


### Cross-Validation and Bootstrap

The bootstrap is useful in providing estimators of the precision, or variability, of statistics. It can also be useful for model validation. The bootstrap approach to model validation is similar to the leave-one-out and *k*-fold validation procedures:

- Create a bootstrap sample by re-sampling (with replacement) $n$ indices in $\{1,\cdots,n\}$. That will be our *training sample*. Estimate the model under consideration based on this sample.
- The *test*, or *validation sample*, consists of those observations not selected for training. Evaluate the fitted model (based on the training data) using the test data.

Repeat this process many (say $B$) times. Take an average over the results and choose the model based on the average evaluation statistic.


**Example `r chapnum`.3.4. Wisconsin Property Fund.**  Return to Example `r chapnum`.3.1 where we investigate the fit of the gamma and Pareto distributions on the property fund data. We again compare the predictive performance using the Kolmogorov-Smirnov (*KS*) statistic but this time using the bootstrap procedure to split the data between training and testing samples. The following provides illustrative code.

`r HideRCode('BootstrapValidation.1','Show R Code for Bootstrapping Validation Procedures')`

```{r, warning=FALSE, comment=FALSE, echo=SHOW_PDF}
# library(MASS)
# library(VGAM)
# library(goftest)
# claim_lev <- read.csv("../Data/CLAIMLEVEL.csv", header = TRUE) 
# # 2010 subset 
# claim_data <- subset(claim_lev, Year == 2010); 
n <- nrow(claim_data)
set.seed(12347)
indices <- 1:n
# Number of Bootstrap Samples
B <- 100
cvalvec <- matrix(0,2,B)
for (i in 1:B) {
  bootindex <- unique(sample(indices, size=n, replace= TRUE))
  traindata <- claim_data[bootindex,]
  testdata  <- claim_data[-bootindex,]
# Pareto
  fit.pareto <- vglm(Claim ~ 1, paretoII, loc = 0, data = traindata)
  ksResultPareto <- ks.test(testdata$Claim, "pparetoII", loc = 0, shape = exp(coef(fit.pareto)[2]), 
        scale = exp(coef(fit.pareto)[1]))
  cvalvec[1,i] <- ksResultPareto$statistic
# Gamma
  fit.gamma <- glm(Claim ~ 1, data = traindata, family = Gamma(link = log)) 
  gamma_theta <- exp(coef(fit.gamma)) * gamma.dispersion(fit.gamma)  
  alpha <- 1 / gamma.dispersion(fit.gamma)
  ksResultGamma <- ks.test(testdata$Claim, "pgamma", shape = alpha, scale = gamma_theta)
  cvalvec[2,i] <- ksResultGamma$statistic
}
KSBoot <- rowSums(cvalvec)/B

```

</div>

We did the sampling using $B=$ `r B` replications. The average *KS* statistic for the Pareto distribution was `r round (KSBoot[1], digits = 3)` compared to the average for the gamma distribution, `r round (KSBoot[2], digits = 3)`. This is consistent with earlier results and provides another piece of evidence that the Pareto is a better model for these data than the gamma.



## Importance Sampling {#S:ImportanceSampling}


<!-- ## Importance Sampling -->

Section \@ref(S:SimulationFundamentals) introduced Monte Carlo techniques using the inversion technique : to generate a random variable $X$ with distribution $F$, apply $F^{-1}$ to calls of a random generator (uniform on the unit interval). What if we what to draw according to $X$, conditional on $X\in[a,b]$ ?

One can use an `r Gloss('accept-reject mechanism')` : draw $x$ from distribution $F$

- if $x\in[a,b]$ : keep it ("*accept*")
- if $x\notin[a,b]$ : draw another one ("*reject*")

Observe that from $n$ values initially generated, we keep here only $[F(b)-F(a)]\cdot n$ draws, on average.



**Example `r chapnum`.4.1. Draws from a Normal Distribution.** Suppose that we draw from a normal distribution with mean 2.5 and variance 1, $N(2.5,1)$, but are only interested in draws greater that $a \ge 2$ and less than $b \le 4$. That is, we can only use $F(4)-F(2) = \Phi(4-2.5)-\Phi(2-2.5)$ = `r round(pnorm(4,2.5,1),digits=4)` - `r round(pnorm(2,2.5,1),digits=4)` = `r round(pnorm(4,2.5,1)-pnorm(2,2.5,1),digits=4)` proportion of the draws. Figure \@ref(fig:sampleani1) demonstrates that some draws lie with the interval $(2,4)$ and some are outside.

`r HideRCode('ImportanceSampling.1','Show R Code for Accept-Reject Mechanism')`

```{r eval = ANIMATION, comment = "", fig.align='center', out.width='50%', fig.asp=.75, echo=SHOW_PDF, animation.hook=ANIMATIONHOOK, cache = TRUE}
mu = 2.5
sigma = 1
a = 2
b = 4
Fa = pnorm(a,mu,sigma)
Fb = pnorm(b,mu,sigma)
pic_ani = function(){
  u=seq(0,5,by=.01)
  plot(u,pnorm(u,mu,sigma),col="white",ylab="",xlab="")
  rect(-1,-1,6,2,col=rgb(1,0,0,.2),border=NA)
  rect(a,Fa,b,Fb,col="white",border=NA)
  lines(u,pnorm(u,mu,sigma),lwd=2)
  abline(v=c(a,b),lty=2,col="red")
  ru <- runif(1)
  clr <- "red"
  if((qnorm(ru,mu,sigma)>=a)&(qnorm(ru,mu,sigma)<=b)) clr <- "blue"
  segments(-1,ru,qnorm(ru,mu,sigma),ru,col=clr,lwd=2)
  arrows(qnorm(ru,mu,sigma),ru,qnorm(ru,mu,sigma),0,col=clr,lwd=2,length = .1)
}

```

</div>

(ref:sampleani1) **Animated Demonstration of Draws In and Outside of (2,4)**

```{r sampleani1, animation.hook=ANIMATIONHOOK, fig.cap='(ref:sampleani1)', eval = ANIMATION, comment = "", fig.align='center', out.width='50%', fig.asp=.75, echo=SHOW_PDF, cache = TRUE}
for (i in 1:numAnimation) {pic_ani()}
```

***

Instead, one can draw according to the conditional distribution $F^{\star}$ defined as

$$
F^{\star}(x) = \Pr(X \le x | a < X \le b) =\frac{F(x)-F(a)}{F(b)-F(a)}, \ \  \ \text{for } a < x \le b .
$$

Using the inverse transform method in Section \@ref(S:InverseTransform), we have that the draw

$$
X^\star=F^{\star-1}\left( U \right) = F^{-1}\left(F(a)+U\cdot[F(b)-F(a)]\right)
$$

has distribution $F^{\star}$. Expressed another way, define
$$
\tilde{U} = (1-U)\cdot F(a)+U\cdot F(b)
$$
and then use $F^{-1}(\tilde{U})$. With this approach, each draw counts.

This can be related to the `r Gloss('importance sampling mechanism')` : we draw more frequently in regions where we expect to have quantities that have some interest. This transform can be considered as a "a change of measure."

`r HideRCode('ImportanceSampling.2','Show R Code for Importance Sampling by the Inverse Transform Method')`

```{r eval = ANIMATION, echo=SHOW_PDF, animation.hook=ANIMATIONHOOK, cache = TRUE}
pic_ani = function(){
  u=seq(0,5,by=.01)
  plot(u,pnorm(u,mu,sigma),col="white",ylab="",xlab="")
  rect(-1,-1,6,2,col=rgb(1,0,0,.2),border=NA)
  rect(a,Fa,b,Fb,col="white",border=NA)
  lines(u,pnorm(u,mu,sigma),lwd=2)
  abline(h=pnorm(c(a,b),mu,sigma),lty=2,col="red")
  ru <- runif(1)
  rutilde <- (1-ru)*Fa+ru*Fb
  segments(-1,rutilde,qnorm(rutilde,mu,sigma),rutilde,col="blue",lwd=2)
  arrows(qnorm(rutilde,mu,sigma),rutilde,qnorm(rutilde,mu,sigma),0,col="blue",lwd=2,length = .1)
}

```

</div>

```{r sampleani_IS_2, eval = ANIMATION, fig.align='center', out.width='50%', fig.asp=.75, echo=SHOW_PDF, animation.hook=ANIMATIONHOOK, cache = TRUE}
for (i in 1:numAnimation) {pic_ani()}
```

In Example `r chapnum`.4.1., the inverse of the normal distribution is readily available (in `R`, the function is `qnorm`). However, for other applications, this is not the case. Then, one simply uses numerical methods to determine $X^\star$ as the solution of the equation $F(X^\star) =\tilde{U}$ where $\tilde{U}=(1-U)\cdot F(a)+U\cdot F(b)$. See the following illustrative code.


`r HideRCode('ImportanceSampling.3','Show R Code for Importance Sampling via Numerical Solutions')`

```{r eval = ANIMATION, comment = "", echo=SHOW_PDF, animation.hook=ANIMATIONHOOK, cache = TRUE}
pic_ani = function(){
  u=seq(0,5,by=.01)
  plot(u,pnorm(u,mu,sigma),col="white",ylab="",xlab="")
  rect(-1,-1,6,2,col=rgb(1,0,0,.2),border=NA)
  rect(2,-1,4,2,col="white",border=NA)
  lines(u,pnorm(u,mu,sigma),lty=2)
  pnormstar <- Vectorize(function(x){
    y=(pnorm(x,mu,sigma)-Fa)/(Fb-Fa)
    if(x<=a) y <- 0
    if(x>=b) y <- 1
    return(y)
    })
  qnormstar <- function(u) as.numeric(uniroot((function (x) pnormstar(x) - u), lower = 2, upper = 4)[1])
  lines(u,pnormstar(u),lwd=2)
  abline(v=c(2,4),lty=2,col="red")
  ru <- runif(1)
  segments(-1,ru,qnormstar(ru),ru,col="blue",lwd=2)
  arrows(qnormstar(ru),ru,qnormstar(ru),0,col="blue",lwd=2,length = .1)
}

```

</div>

```{r sampleani_IS_1, eval = ANIMATION, comment = "", fig.align='center', out.width='50%', fig.asp=.75, echo=SHOW_PDF, animation.hook=ANIMATIONHOOK, cache = TRUE}
for (i in 1:numAnimation) {pic_ani()}
```



## Monte Carlo Markov Chain (MCMC)  {#S:MCMC}


***

**This section is being written and is not yet complete nor edited. It is here to give you a flavor of what will be in the final version.**

***



<!-- ## MCMC -->


The idea of Monte Carlo techniques rely on the law of large numbers (that insures the convergence of the average towards the integral) and the central limit theorem (that is used to quantify uncertainty in the computations). Recall that if $(X_i)$ is an *iid* sequence of random variables with distribution $F$, then

$$
\frac{1}{\sqrt{n}}\left(\sum_{i=1}^n h(X_i)-\int h(x)dF(x)\right)\overset{\mathcal{L}}{\rightarrow }\mathcal{N}(0,\sigma^2),\text{ as }n\rightarrow\infty ,
$$
for some variance $\sigma^2>0$. But actually, the `r Gloss('ergodic theorem')` can be used to weaker the previous result, since it is not necessary to have independence of the variables. More precisely, if $(X_i)$ is a `r Gloss('Markov Process')` with `r Gloss('invariant measure')` $\mu$, under some additional technical assumptions, we can obtain that

$$
\frac{1}{\sqrt{n}}\left(\sum_{i=1}^n h(X_i)-\int h(x)d\mu(x)\right)\overset{\mathcal{L}}{\rightarrow }\mathcal{N}(0,\sigma_\star^2),\text{ as }n\rightarrow\infty.
$$
for some variance $\sigma_\star^2>0$.

Hence, from this property, we can see that it is possible not necessarily to generate independent values from $F$, but to generate a Markov process with invariant measure $F$, and to consider means over the process (not necessarily independent).

Consider the case of a constrained Gaussian vector : we want to generate random pairs from a random vector $\boldsymbol{X}$, but we are interested only in the case where the sum of the `r Gloss('composants')` is large enough, which can be written $\boldsymbol{X}^T\boldsymbol{1}> m$ for some real valued $m$. Of course, it is possible to use the *accept-reject* algorithm, but we have seen that it might be quite inefficient. One can use `r Gloss('Metropolis Hastings')` and `r Gloss('Gibbs sampler')` to generate a Markov process with such an invariant measure.

### Metropolis Hastings 

The algorithm is rather simple to generate from $f$: we start with a feasible value $x_1$. Then, at step $t$, we need to specify a transition kernel : given $x_t$, we need a conditional distribution for $X_{t+1}$ given $x_t$. The algorithm will work well if that conditional distribution can easily be simulated. Let $\pi(\cdot|x_t)$ denote that probability.

Draw a potential value $x_{t+1}^\star$, and $u$, from a uniform distribution. Compute 
$$
R=  \frac{f(x_{t+1}^\star)}{f(x_t)}
$$
and 

- if $u < r$, then set $x_{t+1}=x_t^\star$
- if $u\leq r$, then set $x_{t+1}=x_t$

Here $r$ is called the *acceptance*-ratio: we accept the new value with probability $r$ (or actually the smallest between $1$ and $r$ since $r$ can exceed $1$).

For instance, assume that $f(\cdot|x_t)$ is uniform on $[x_t-\varepsilon,x_t+\varepsilon]$ for some $\varepsilon>0$, and where $f$ (our target distribution) is the $\mathcal{N}(0,1)$. We will never *draw* from $f$, but we will use it to compute our acceptance ratio at each step.

`r HideRCode('MCMC.1','Show R Code')`

```{r echo=SHOW_PDF}
metrop1 <- function(n=1000,eps=0.5){
 vec <- matrix(NA, n, 3)
 x=0
 vec[1] <- x
 for (i in 2:n) {
 innov <- runif(1,-eps,eps)
 mov <- x+innov
 R <- min(1,dnorm(mov)/dnorm(x))
 u <- runif(1)
 if (u < R) x <- mov
 vec[i,] <- c(x,mov,R)
 }
return(vec)}
```

</div>

In the code above, `vec` contains values of $\boldsymbol{x}=(x_1,x_2,\cdots)$, `innov` is the innovation.

`r HideRCode('MCMC.2','Show R Code')`

```{r eval = ANIMATION, echo=SHOW_PDF, animation.hook=ANIMATIONHOOK, cache = TRUE}
#install.packages('gifski')
#if (packageVersion('knitr') < '1.20.14') {
#  remotes::install_github('yihui/knitr')
#}
vec <- metrop1(25)
u=seq(-3,3,by=.01)
pic_ani = function(k){
  plot(1:k,vec[1:k,1],pch=19,xlim=c(0,25),ylim=c(-2,2),xlab="",ylab="")
    if(vec[k+1,1]==vec[k+1,2]) points(k+1,vec[k+1,1],col="blue",pch=19)
    if(vec[k+1,1]!=vec[k+1,2]) points(k+1,vec[k+1,1],col="red",pch=19)
  points(k+1,vec[k+1,2],cex=1.5)
  arrows(k+1,vec[k,1]-.5,k+1,vec[k,1]+.5,col="green",angle=90,code = 3,length=.1)
  polygon(c(k+dnorm(u)*10,rep(k,length(u))),c(u,rev(u)),col=rgb(0,1,0,.3),
          border=NA)  
  segments(k,vec[k,1],k+dnorm(vec[k,1])*10,vec[k,1])
  segments(k,vec[k+1,2],k+dnorm(vec[k+1,2])*10,vec[k+1,2])
  text(k,2,round(vec[k+1,3],digits=3))
}

```

</div>

```{r sampleani_HM_1, eval = ANIMATION, echo=SHOW_PDF, animation.hook=ANIMATIONHOOK}
for (k in 2:23) {pic_ani(k)}
```



Now, if we use more simulations, we get


```{r  eval = ANIMATION, echo=SHOW_PDF, cache = TRUE}
vec <- metrop1(10000)
simx <- vec[1000:10000,1]
par(mfrow=c(1,4))
plot(simx,type="l")
hist(simx,probability = TRUE,col="light blue",border="white")
lines(u,dnorm(u),col="red")
qqnorm(simx)
acf(simx,lag=100,lwd=2,col="light blue")
```


### Gibbs Sampler

Consider some vector $\boldsymbol{X}=(X_1,\cdots,X_d)$ with independent components, $X_i \sim \mathcal{E}(\lambda_i)$. We sample to sample from $\boldsymbol{X}$ given $\boldsymbol{X}^T\boldsymbol{1}>s$ for some threshold $s>0$.

- with some starting point  $\boldsymbol{x}_0$, 
- pick up (randomly) $i\in\{1,\cdots,d\}$
- $X_i$ given $X_i > s-\boldsymbol{x}_{(-i)}^T\boldsymbol{1}$ has an Exponential distribution $\mathcal{E}(\lambda_i)$
- draw $Y\sim \mathcal{E}(\lambda_i)$ and set $x_i=y +(s-\boldsymbol{x}_{(-i)}^T\boldsymbol{1})_+$ until $\boldsymbol{x}_{(-i)}^T\boldsymbol{1}+x_i>s$

`r HideRCode('Gibbs.1','Show R Code')`

```{r echo=SHOW_PDF}
sim <- NULL
 lambda <- c(1,2)
 X <- c(3,3)
 s <- 5
 for(k in 1:1000){
 i <- sample(1:2,1)
 X[i] <- rexp(1,lambda[i])+max(0,s-sum(X[-i]))
 while(sum(X)<s){
 X[i] <- rexp(1,lambda[i])+max(0,s-sum(X[-i])) }
 sim <- rbind(sim,X) }

```

</div>

```{r echo=SHOW_PDF}
plot(sim,xlim=c(1,11),ylim=c(0,4.3))
polygon(c(-1,-1,6),c(-1,6,-1),col="red",density=15,border=NA)
abline(5,-1,col="red")
```

The construction of the sequence (`r Gloss('MCMC')` algorithms are iterative) can be visualized below

`r HideRCode('Gibbs.2','Show R Code')`

```{r, echo=SHOW_PDF, cache = TRUE}
lambda <- c(1,2)
X <- c(3,3)
sim <- X
s <- 5
for(k in 1:100){
 set.seed(k)
 i <- sample(1:2,1)
 X[i] <- rexp(1,lambda[i])+max(0,s-sum(X[-i]))
 while(sum(X)<s){
 X[i] <- rexp(1,lambda[i])+max(0,s-sum(X[-i])) }
 sim <- rbind(sim,X) }
pic_ani = function(n){
plot(sim[1:n,],xlim=c(1,11),ylim=c(0,5),xlab="",ylab="")
i=which(apply(sim[(n-1):n,],2,diff)==0)
if(i==1) abline(v=sim[n,1],col="grey")
if(i==2) abline(h=sim[n,2],col="grey")
if(n>=1) points(sim[n,1],sim[n,2],pch=19,col="blue",cex=1.4)
if(n>=2) points(sim[n-1,1],sim[n-1,2],pch=19,col="red",cex=1.4)
polygon(c(-1,-1,6),c(-1,6,-1),col="red",density=15,border=NA)
abline(5,-1,col="red")
}
```

</div>

```{r sampleani_HM, eval = ANIMATION, echo=SHOW_PDF, animation.hook=ANIMATIONHOOK, cache = TRUE}
for (i in 2:100) {pic_ani(i)}
```

## Further Resources and Contributors {#Simulation:further-reading-and-resources}

-  Include historical references for jackknife (Quenouille, Tukey, Efron)
-  Here are some links to learn more about [reproducibility and randomness](https://freakonometrics.hypotheses.org/6470) and how to go
[from a random generator to a sample function](https://freakonometrics.hypotheses.org/6638).


#### Contributors {-}

- **Arthur Charpentier**, Universit&eacute; du Quebec &aacute; Montreal, and **Edward W. (Jed) Frees**, University of Wisconsin-Madison, are the principal authors of the initial version of this chapter. Email: jfrees@bus.wisc.edu and/or arthur.charpentier@gmail.com for chapter comments and suggested improvements.
- Chapter reviewers include Yvonne Chueh and Brian Hartman. Write Jed or Arthur to add you name here.



### TS `r chapnum`.A. Bootstrap Applications in Predictive Modeling

***

**This section is under construction.**

***





